#define _CRT_SECURE_NO_WARNINGS 1
//自定义类型：结构体、枚举、联合
//一、结构体
//1、结构体类型的声明 
//结构的基础知识：结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。

//声明结构体类型的格式：
/*
	struct tag结构体名称
	{
		member - list//成员变量声明列表
	}variable-list;//结构体变量列表;
*/

//声明一个结构体类型
//例如：描述一个学生：声明一个学生类型，想通过学生类型来创建学生变量(对象)
//描述学生：属性 - 名字+电话+性别+年龄...
/*
#include <stdio.h>
struct Stu
{
	char name[20];//名字
	int age;//年龄
	char sex[5];//性别
	char tele[12];//电话
}s4, s5, s6; //声明结构体类型struct Stu，并创建结构体变量s4,s5,s6，均为全局变量，且分号不能丢

struct Stu s3;//全局变量s3
int main()
{
	//创建结构体局部变量s1,s2
	struct Stu s1;
	struct Stu s2;
  return 0;
}
*/

//特殊的声明
//在声明结构的时候，可以不完全的声明。
//如：匿名结构体类型
//注意：匿名结构体只能用一次
/*
#include <stdio.h>
struct
{
	int a;
	char b;
	float c;
}x;//匿名结构体变量x
struct
{
	int a;
	char b;
	float c;
}a[20], *p;//匿名结构体数组，匿名结构体指针p
//上面的两个结构在声明的时候由于省略掉了结构体标签（tag）。
//只能通过声明结构体类型的同时创建结构体变量
int main()
{
	p = &x;//会报警告
	//尽管成员变量是相同的，但编译器会把上面的两个匿名结构体声明当成完全不同的两个类型。
	return 0;
}
*/

//2、结构的自引用
//数据结构：数据在内存中的存储方式的结构
//如：链表是通过结点将分布在内存不同地方的数据联系在一起的一种结构，此时为了实现联系，即结构体找到同类型的其他变量
//每个节点一部分存数据，一部分存执行下一个节点的地址，而最后一个节点存NULL空指针，即数据域+指针域
/*
struct Node
{
	int data;//数据域 - 4字节

	//链表方式的错误实现：
	//struct Node n;//存放下一个结构体节点的变量
	//注意：结构体类型的成员变量不能包含本身结构体类型的变量
	//当sizeof(struct Node);无法计算结构体占用空间大小，因为n包含data+n,n又包含data+n ...无限展开
	
	//链表方式的正确实现
	struct Node* next;//指针域 - 4/8字节
	//存放要指向的下一个结构体节点的地址
};
*/

//结构体类型的重命名
/*
#include <stdio.h>
typedef struct Node
{
	int data;
	struct Node* next;
}Node; //将struct Node类型重命名为Node。注意：这个是结构体类型，不是结构体变量。
int main()
{
	struct Node n1;
	Node n2;
	//struct Node 和Node为同名结构体类型
	return 0;
}
*/

//以下书写方式是错误的，由于Node的使用在声明之前
/*
#include <stdio.h>
typedef struct
{
	int data;
	Node* next;//报错，因为程序是从上而下编译的，此时匿名结构体还未被命名为Node，就使用，显然不合适
}Node;
int main()
{
	//struct Node n1;
	Node n2;
	//struct Node 和Node为同名结构体类型
	return 0;
}
*/

//3、结构体变量的定义和初始化
//结构体变量的定义：
/*
struct Point
{
	int x;
	int y;
}p1; //声明类型的同时定义结构体变量p1。注意：这个是结构体变量，不是结构体类型。
struct Point p2; //定义结构体变量p2
*/

//结构体变量的初始化：
/*
#include <stdio.h>
struct T
{
	double weight;
	short age;
};
struct S
{
	char c;
	struct T st;//结构体包含其他结构体类型的成员。注意：不能是本结构体类型的成员
	int a;
	double d;
	char arr[20];
}s1 = { 'c',{ 55.6, 30 },100,3.14,"hello bit" };//结构体嵌套初始化
struct S s2= { 'c',{ 55.6, 30 },100,3.14,"hello bit" };//结构体嵌套初始化
int main()
{
	//结构体嵌套初始化
	struct S s = { 'c',{ 55.6, 30 },100,3.14,"hello bit" };//定义结构体变量s，并初始化
	//结构体成员访问
	printf("%c %d %lf %s\n", s.c, s.a, s.d, s.arr);
	printf("%lf\n", s.st.weight);
	return 0;
}
*/

//4、结构体内存对齐
//如何计算结构体类型的所占空间的大小？
//首先得掌握结构体的对齐规则：
/****************************************************************************************************************
//1. 第一个成员总是 在与结构体变量偏移量为0的地址处。

//2. 其他成员变量要对齐到某个数字（即编译器默认的一个对齐数 与 该成员所占空间大小的较小值。）的整数倍的地址处。即偏移量为某个数字（或对齐数）的整数倍的地址处

//注意：对齐数 = 编译器默认的一个对齐数 与 该成员所占空间大小的较小值。
//VS编译器的默认对齐数的值为8
//gcc编译器，没有默认对齐数，即对齐数直接选择该成员大小作为对齐数

//3. 结构体总大小 为每个成员变量的对齐数中最大对齐数的整数倍。
//注意：每个成员变量都有一个对齐数

//4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的每个成员变量中最大对齐数的整数倍处，结构体的整体大小就是所有成员变量中（含嵌套结构体的对齐数）最大对齐数的整数倍。

//注意：
//最后一个偏移量 - 0 + 1 = 结构体总大小
//计算结构体总大小时，先(按1,2,4规则)计算出结构体总大小，再(按3规则)判断总大小是不是“为每个成员变量的对齐数中最大对齐数”的整数倍。
//若是，则取该大小为结构体大小；
//若不是，则取“每个成员变量的对齐数中最大对齐数”的整数倍，(前提至少能容纳所有成员的空间)满足条件下的最小值。
//如：第一个成员变量(占1个字节)位于偏移量0处，第二个成员变量(占4个字节)位于偏移量4处，第三个成员(占1个字节)位于偏移量8处
//容纳所有成员的空间需要：0 4-7 8共9个字节，总大小不满足4的整数倍，应为取总大小为：12字节

//总结：
//成员中有结构体：则对齐数 = 自己的每个成员变量中对齐数的最大值
//成员中有数组：则对齐数 = 某个元素的空间大小 与 编译器默认对齐数的较小值
//成员中有指针：则对齐数 = 指针空间大小 与 编译器默认对齐数的较小值
//注意：对于long类型和指针类型，因32位机和64位机不同，对齐数也不同
****************************************************************************************************************/
/*
#include <stdio.h>
struct S1
{
	char c1;	//c1存放方式：放在结构体变量偏移量为0的地址处
	int a;		//a 存放方式：所占空间大小为4与编译器对齐数8比较，选4，即放在偏移量为4的整数倍的地址处
	char c2;	//c2存放方式：所占空间大小为1与编译器的对齐数8比较，选1，即放在偏移量为1的整数倍的地址处
	//结构体所占空间的总大小：0 4-7 8共9个字节，选各成员变量中对齐数（1，4，1）的最大值，选4，即结构体所占空间的总大小为4的整数倍
};
struct S2
{
	char c1;
	char c2;
	int a;
};
int main()
{
	printf("%d\n", sizeof(S1));//12
	//将成员变量的第一个变量初始化为0，其余按默认方式初始化为0
	struct S2 s2 = { 0 };
	printf("%d\n", sizeof(s2));//8
	return 0;
}
*/
/*
//练习3
#include <stdio.h>
struct S3
{
	double d;	//0-7（8/8，地址偏移量对齐到0处）
	char c;		//8  9-11（1/8，地址偏移量对齐到1的倍数处）
	int i;		//12-15（4/8，地址偏移量对齐到4的倍数处）
	//0-15一共16个字节，由于16是最大对齐数（8/1/4）的整数倍，所以S3的大小就是16字节
};
//练习4
struct S4
{
	char c1;		//c1存放方式：放在结构体变量偏移量为0的地址处
	struct S3 s3;	//s3存放方式：嵌套的结构体对齐到自己的最大对齐数(8,1,4)的整数倍处，即放在偏移量为8的整数倍的地址处
	double d;		//d 存放方式：所占空间大小为8与编译器对齐数8比较，选8，即放在偏移量为8的整数倍的地址处
	//此时结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。即8的整数倍
	//结构体所占空间的总大小：0 8-23 24-31共32个字节，选各成员变量中对齐数（1，8，8）的最大值，选8，即结构体所占空间的总大小为8的整数倍
	//
};
//char c1;0（1/8，地址偏移量对齐到0处）
//c1存放方式：放在结构体变量偏移量为0的地址处
//struct S3 s3;8-23（8/8，地址偏移量对齐到8倍数处）
//s3的存放方式：嵌套的结构体对齐到自己的最大对齐数（8/1/4）的整数倍处，即放在8的整数倍的地址处
//double d;24-31 （8/8，地址偏移量对齐到8倍数处）
//d的存放方式：所占空间大小为8与编译器对齐数8比较，选8，即放在8的整数倍的地址处
//此时结构体的整体大小就是最大对齐数（含嵌套结构体的对齐数）（1/8/8）的整数倍。即8的整数倍
int main()
{
	printf("%d\n", sizeof(struct S3));//8+1+3+4 = 16，由于总大小为8的倍数，故总大小为16字节
	//结构体嵌套问题
	printf("%d\n", sizeof(struct S4));//1+7+16+8 = 32，由于总大小为8的倍数，故总大小为32字节
	return 0;
}
*/
/*
//练习5
#include <stdio.h>
#include <stddef.h>//offsetof的头文件
struct S5
{
	int i;		//对齐数为4  0-3
	char c;		//对齐数为1  4    5-7
	double d;	//对齐数为8  8-15
	char a[1];	//对齐数为1  16
	//S5的大小为0-16 一共17个字节，不是最大对齐数的整数倍，所以S5的大小为24
};
//练习6
struct S6
{
	char* b;//（32位机：4/8，放在结构体变量偏移量为0的地址处）（64位机：8/8，放在结构体变量偏移量为0的地址处）
	//32位：结构体所占空间的总大小：0-3共4个字节，选各成员变量中对齐数（4）的最大值，选4，即结构体所占空间的总大小为4的整数倍
	//64位：结构体所占空间的总大小：0-7共8个字节，选各成员变量中对齐数（8）的最大值，选8，即结构体所占空间的总大小为8的整数倍
};
//练习7
struct S7
{
	char a;	//0 （1/8，地址偏移量对齐到0处）
	char* b;//4 - 7 / 8 - 15 //（32位机：4/8，放在结构体变量偏移量为4的地址处）（64位机：8/8，放在结构体变量偏移量为8的地址处）
	int c;	//8-11/16-19（4/8，地址偏移量对齐到4倍数处）
	//0-11/19一共12/20个字节，由于12/20是/不是最大对齐数（4/8）的整数倍，所以S3的大小就是12/24字节
};
int main(void)
{
	//offsetof计算结构体成员的地址偏移量
	printf("offsets: i=%zd; c=%zd; d=%zd a=%zd\n",
		offsetof(struct S5, i), offsetof(struct S5, c),
		offsetof(struct S5, d), offsetof(struct S5, a));
	//%zd是强制转换为整型的格式输出符，对应的是size_t类型
	//有些编译器可能不支持，它可能支持%u或%lu
	printf("sizeof(struct S5)=%zd\n", sizeof(struct S5));//24
	
	printf("sizeof(struct S6)=%zd\n", sizeof(struct S6));//32位-4字节 64位-8字节

	printf("offsets: a=%zd; b=%zd; c=%zd\n",
		offsetof(struct S7, a), offsetof(struct S7, b),
		offsetof(struct S7, c));
	printf("sizeof(struct S7)=%zd\n", sizeof(struct S7));//32位-12字节 64位-24字节
	
	return 0;
}
*/

//为什么存在内存对齐?
//原因在于，为了访问未对齐的内存，处理器可能需要作两次内存访问；而对齐的内存访问仅需要一次访问。
//结构体的内存对齐是一种拿空间来换取时间的做法。	-- 类似“计算机组成原理”中的数据在内存中的存储
//如：当32位机器上(32根数据线读取一次拿到4个字节)，某结构体struct S{ char c; int a; };
//如果没有内存对齐，则c和a的存储是相邻的。读取a时需要先读取c拿到4个字节(包含a的3个字节)，再读一次拿到4个字节(包含a的1个字节)。因此读取a时就需要访问2次
//如果存在内存对齐，则c和a的存储不相邻的。读取a时只需要一次就能全部拿到a的4个字节。因此读取a时就只需要访问1次

//那在设计结构体的时候，我们既要满足对齐，又要节省空间，如何做到：让占用空间小的成员尽量集中在一起，减少空间浪费。
//如：S1和S2类型的成员一模一样，但是S1和S2所占空间的大小有了一些区别。
/*
struct S1
{
	char c1;
	int i;
	char c2;
};
struct S2
{
	char c1; //让占用空间小的成员c1和c2尽量集中在一起。
	char c2;
	int i;
};
*/
/*
#include <stdio.h>
struct S4
{
	char c1;//1/8		0 1-3
	char* b;//4或8/8	4-7/8-15
	short int c;//2/8	8-9/16-17
	//10 12
	//18 24
};
int main()
{
	struct S4 s;

	printf("%d\n", sizeof(struct S4));//12/24
	printf("%p\n", &s);
	printf("%p\n", &s + 1);
	//地址相差12个字节
}
*/

//修改编译器的默认对齐数
/*
#include <stdio.h>
#pragma pack(4)//设置默认对齐数为4
struct S
{
	char c;
	double d;
	//对齐数为8时：1 + 7 + 8 = 16
	//对齐数为4时：1 + 3 + 8 = 12
	//对齐数为1时：1 + 8 = 9//会导致访问数据两次，增加了处理的时间
};
#pragma pack()//取消设置的默认对齐数
//若存在多个#pragma pack (n),遵从向上对齐原则，即某个结构体定义上方最近的一个#pragma pack（）
int main()
{
	struct S s;
	printf("%d\n", sizeof(s));
	return 0;
}
*/

//offsetof()用于计算结构体成员相对于结构体起始地址的偏移量大小
//offsetof()是宏，不是函数，类似于sizeof()也是一个宏
//查看MSDN手册，了解使用规则size_t offsetof(structName,memberName);
/*
#include <stdio.h>
#include <stddef.h>
struct S
{
	char c;		//0 1-3
	int i;		//4-7
	double d;	//8-15
};
int main()
{
	printf("%d\n", offsetof(struct S, c));//0
	printf("%d\n", offsetof(struct S, i));//4
	printf("%d\n", offsetof(struct S, d));//8
	return 0;
}
*/

//百度笔试题：
//写一个宏，计算结构体中某变量相对于首地址的偏移，并给出说明
//考察： offsetof 宏的实现
//注：这里还没学习宏，可以放在宏讲解完后再实现。详见“test17.c”
//模拟实现offsetof
//思路：假设0地址就是结构体变量的地址，则成员变量的地址即为各自的偏移量
/*#include <stdio.h>
struct S
{
	char c1;
	int a;
	char c2;
};
#define OFFSETOF(struct_name,member_name) (int)&(((struct_name*)0)->member_name)
//将0强制类型转化为结构体指针的地址
int main()
{
	printf("%d\n", OFFSETOF(struct S, c1));
	printf("%d\n", OFFSETOF(struct S, a));
	printf("%d\n", OFFSETOF(struct S, c2));
	return 0;
}
*/

//5、结构体传参
/*
#include <stdio.h>
struct S
{
	int a;
	char c;
	double d;
};
//传值调用：形参的改变，不会影响实参
//由于值传递，形参tmp是实参的一份临时拷贝，拥有各自独立的空间，改变的是tmp空间的值，但不会改变实参s的值
void Init1(struct S tmp)
{
	tmp.a = 100;
	tmp.c = 'w';
	tmp.d = 3.14;
}
//传址调用:函数内部想改变函数外部变量的值，使用传址调用
void Init2(struct S *tmp)
{
	//(*tmp).a = 100;
	//(*tmp).c = 'w';
	//(*tmp).d = 3.14;
	tmp->a = 100;
	tmp->c = 'w';
	tmp->d = 3.14;
}
//传值调用：函数内部只是显示或打印实参传过来的值，而不改变函数外部变量的值，使用传值调用
//当使用传值调用方式，传入的成员变量过多时，形参会拷贝一份原大小的副本，导致占用的内存资源更多。
//同时传值过程中系统开销大，效率低。
void Print1(struct S tmp)
{
	printf("%d %c %lf\n", tmp.a, tmp.c, tmp.d);
}
//传址调用：即想要效率高，又不想改变函数外部变量的值，可以使用传址调用的同时加上const修饰变量指针
void Print2(const struct S *ps)//由于只希望打印而不希望改变值，加上const更安全
{
	printf("%d %c %lf\n", ps->a, ps->c, ps->d);
}
int main()
{
	struct S s = { 0 };
	//1、初始化
	//s.a = 100;
	//s.c = 'w';
	//s.d = 3.14;

	//2、自定义初始化结构体成员变量的函数
	Init1(s);
	Print1(s);
	Init2(&s);
	Print2(&s);
	//
	//上面的 print1 和 print2 函数哪个好些？
	//	答案是：首选print2函数。
	//	原因：函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销。
	//	如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的下降。
	//
	//结论：结构体传参的时候，要传结构体的地址。
	return 0;
}
*/

//6、结构体实现位段（位段的填充 & 可移植性）
//什么是位段？
//位段的声明和结构是类似的，有两个不同：
//1.位段的成员必须是整型，如：int、unsigned int、char、short、long int...
//2.位段的成员名后边有一个冒号和一个数字。
//3.位段成员的类型一般都是相同的，也可以不同。
//4.位段的位是bit位，成员名后面的数字表示用多少位表示该成员
//5.位段后面的数字，对于任何整型(如：long)成员而言，不能超过32位，对于字符型成员而言，不能超过8位
//因为位段只能是整型，整型的大小32位。或者是字符类型，字符型的大小8位

//位段的内存分配
//位段大小的计算规则：
/**************************************************************************************
//1. 位段的成员可以是 int、unsigned int、short int或者是 char(属于整形家族)类型

//2. 位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的。
//即如果存储的数据空间不足，则再开辟一个int或char大小的空间来存储数据

//3. 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。
**************************************************************************************/
/*
#include <stdio.h>
struct S//struct S是位段类型
{
	int a : 2;	//a只需要占2个bit位
	int b : 5;	//b只需要占5个bit位
	int c : 10;	//c只需要占10个bit位
	int d : 30;	//d只需要占30个bit位
	//后面的数字，位的大小不能超过8

	//定义int类型的变量，本来需要4个字节存储，但是如果使用位段，则存储数据只需要适应的位的大小，从而节省了空间
	//位段的作用：节省空间
};
int main()
{
	struct S s;
	printf("%d\n", sizeof(s));//8
	//注意：由于位段类型的成员都是相同类型，所以每次开辟的空间都是连续的

	//给位段变量s分配一个int字节(32位)的空间，存放2bit的a，5bit的b，10bit的c，由于剩余15个bit位不够存储30bit的d，被浪费掉，
	//于是，再分配一个int字节(32位)的空间，存放32bit的d，剩余的2个bit位被浪费掉。
	//故，位段变量s的空间大小是8字节。
	
	//为什么浪费掉？即使不浪费，也要再开辟一个int字节存放，所以索性直接浪费掉
	//其实还是在结构体内存对齐的基础上，内存读取的问题，一次只能按顺序读取4个字节，如果不重新开辟空间，d就要读两次
}
*/
/*
//验证位段的存储原理
#include <stdio.h>
struct S
{
	char a : 3;
	char b : 4;
	char c : 5;
	char d : 4;
	//后面的数字，位的大小不能超过8
};
int main()
{
	printf("%d\n", sizeof(S));//3
	//注意：由于位段类型的成员都是相同类型，所以每次开辟的空间都是连续的
	//给位段变量s分配一个char字节(8位)的空间，存放3bit的a，4bit的b，由于剩余1个bit位不够存储5bit的c，被浪费掉
	//于是，再分配一个char字节(8位)的空间，存放5bit的c，由于剩余3个bit位不够存储4bit的d，被浪费掉
	//于是，再分配一个char字节(8位)的空间，存放4bit的d
	//故，位段变量s的空间大小是3字节

	struct S s = { 0 };//初始化为0
	s.a = 10;//00001010 - 只需要3个bit位，即010
	s.b = 20;//00010100 - 只需要4个bit位，即0100
	s.c = 3;// 00000011 - 只需要5个bit位，即00011
	s.d = 4;// 00000100 - 只需要4个bit位，即0100
	//位段s的空间在内存中是如何开辟的？
	//假设：位段在内存中的存放方式：先使用低位的bit位再使用高位bit位
	//注意：由于位段类型的成员都是相同类型，所以每次开辟的空间都是连续的
	//低地址                       高地址
	//   b    a          c           d
	//0 0000 000 | 000 00000 | 0000 0000
	//0 0100 010   000 00011   0000 0100    
	//十六进制：0x220304
	//调试-窗口-内存，查看&s发现，VS编译器下，位段在内存中的存储方式是：先使用低位bit位，再使用高位bit位
	//3. 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。
	//由于C语言标准没有规定位段在内存中的存储方式，不同的编译器对位段存储的实现方式也不相同，导致不能跨平台性
}
*/

//位段的跨平台问题
//1. int 位段被当成有符号数还是无符号数是不确定的。
//2. 位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出问题。但在32位机器是正常的）
//3. 位段中的成员在内存中从左向右分配，还是从右向左分配，标准尚未定义。
//4. 当一个结构包含两个位段(成员后面带数字，即一个位段)，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的。
//总结：
//跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在。

//位段的应用
//如：数据的传输，对数据包添加很多信息，使用位段就能很好的利用空间。
//如：TCP报文段，使用TCP协议将要发送的数据封装成一个报文(即数据部分添加包头信息)，
//虽然数据部分的大小不能减少，但是包头信息可以节省，因此，使用位段设计TCP协议就可以很好的节省空间。

//二、枚举
//枚举顾名思义就是一一列举。把可能的取值一一列举。
//比如，我们现实生活中：
//一周的星期一到星期日是有限的7天，可以一一列举。
//性别有：男、女、保密，也可以一一列举。
//月份有12个月，也可以一一列举

//1、枚举类型的定义
#include <stdio.h>
/*
enum Day//星期
{
	//枚举的可能取值 - 他们是常量，可以对其赋初值，不赋初值时默认值从0依次递增
	//但声明枚举类型的同时赋初值，之后这些常量的值不能被修改
	Mon = 5,
	Tues,
	Wed,
	Thur = 10,
	Fri,
	Sat,
	Sun
};//声明一个枚举类型enum Day，分号不能丢
*/

//2、枚举的使用
/*
enum Sex//性别
{
	//枚举变量的可能取值 - 他们是常量，可以对其赋初值，不赋初值时默认值从0依次递增
	//但声明枚举类型的同时赋初值，之后这些常量的值不能被修改
	MALE,	
	FEMALE = 9,//这是赋初值，不是修改。类似于const int num = 100;
	SECRET
};
enum Color//颜色
{
	//枚举变量的可能取值 - 他们是常量，可以对其赋初值，不赋初值时默认值从0依次递增
	//但声明枚举类型的同时赋初值，之后这些常量的值不能被修改
	RED,
	GREEN,
	BLUE
};
//以上声明的 enum Day ， enum Sex ， enum Color 都是枚举类型。
//{  }中的内容是枚举类型的可能取值，也叫 枚举常量 。
//这些可能取值都是有值的，默认从0开始，一次递增1，当然在定义的时候也可以赋初值。

//可以使用宏定义代替枚举，但不建议。当枚举中的常量很多时,使用宏定义就很不方便
//#define RED 0
//#define GREEN 1
//#define BLUE 2
int main()
{
	//定义枚举变量，并赋初值
	enum Sex s = MALE;
	//声明枚举类型的同时赋初值，之后这些常量的值不能被修改
	//MALE = 0;//报错：表达式必须是可修改的左值。说明MALE是一个常量，不允许修改
	enum Color c = BLUE;
	//只能拿枚举常量给枚举变量赋初值，否则会出现类型差异
	//enum Color c = 2;//尽量避免这种赋值，虽然没有报错，只是编译器的语法检测不严格
	//在C++中这种书写会报错："初始化":无法从"int"转换为"Color"
	
	//int color = RED;

	printf("%d %d %d\n", RED, GREEN, BLUE);//0 1 2
	printf("%d %d %d\n", MALE, FEMALE, SECRET);//0 9 10
	return 0;
}
*/

//3、枚举的优点
//为什么使用枚举？
//我们可以使用 #define 定义常量，为什么非要使用枚举？
//枚举的优点：
//1. 增加代码的可读性和可维护性
//2. 同#define定义的标识符比较，宏定义没有类型，枚举有类型，因此就有类型检查，更加严谨。
//3. 防止了命名污染（封装）
//4. 便于调试，宏定义不便于调试(因为宏定义在预处理阶段就将宏进行替换了，如果一个复杂的宏内部本身就不正确，而程序员调试看到的还是原来的宏，就可能会忽略)
//5. 使用方便，一次可以定义多个常量

//4、计算枚举类型的变量大小
//枚举类型大小的计算规则：
/*****************************************************
//注意：枚举类型的大小总是4个字节
******************************************************/
/*
#include <stdio.h>
enum Sex//性别
{
	MALE = 2,
	FEMALE = 4,
	SECRET = 8
};
int main()
{
	
	enum Sex s = MALE;//MALE是一个整型常量，即相当于把整型赋给了s
	//故，枚举变量的大小是int型的大小
	printf("%d\n", sizeof(s));//4
	printf("%d\n", sizeof(enum Sex));//4
	return 0;
}
*/

//三、联合(联合体、共用体)
//联合也是一种特殊的自定义类型
//这种类型定义的变量也包含一系列的成员，特征是这些成员公用同一块空间（所以联合也叫共用体）。
//因此，联合也可以起到节省空间的作用
//1、联合类型的定义
/*
#include <stdio.h>
union Un
{
	char c;
	int i;
};//联合类型union Un的声明，分号不能丢
int main()
{
	//联合变量的定义
	union Un u;
	//计算联合变量的大小
	printf("%d\n", sizeof(u));//4
	printf("%p\n", &u);
	printf("%p\n", &(u.c));
	printf("%p\n", &(u.i));
	//通过结果发现，地址相同，说明联合中成员的首地址都相同，即共用同一块空间
	//联合的存储原理分析：
	//由于联合成员变量c和i共用同一块空间，c占用该空间的1个字节，i占用该空间的4个字节
	//c和i首地址相同，共享1个字节的大小
	//即：总大小为4字节，前1个字节分给c成员，前4个字节分给i成员
  return 0;
}
*/

//2、联合的特点
//联合的成员是共用同一块内存空间的，这样一个联合变量的大小，至少是最大成员的大小（因为联合至少得有能力保存最大的那个成员）。
//注意：联合变量不能同时对成员进行操作，否则会改变另外一个成员变量
/*
#include <stdio.h>
union Un
{
	int i;
	char c;
};
int main()
{
	union Un un;
	// 下面输出的结果是一样的吗？
	printf("%d\n", &(un.i));
	printf("%d\n", &(un.c));
	//下面输出的结果是什么？
	un.i = 0x11223344;//44 33 22 11
	un.c = 0x55;
	//联合变量un在内存中的存储布局：
	//低位	   高位
	//44 33 22 11   un.i
	//55			un.c
	//55 33 22 11   un
	printf("%x\n", un.i);//11223355
	//注意：打印需要还原顺序
	return 0;
}
*/

//回顾：
//大小端字节序问题 - 数据，每个字节在内存中的存放顺序问题
//大端字节序：低字节数据存放在内存的低地址处
//小端字节序：高字节数据存放在内存的低地址处
//如：int a = 0x11223344在内存中的存储布局
//低地址								高地址
//...[][][][][][11][22][33][44][][][][][][][]...  大端字节序(顺序相同)
//...[][][][][][44][33][22][11][][][][][][][]...  小端字节序(顺序相反)
//注意：
//低地址：地址编号小的，高地址：地址编号大的。即左小右大。
//高字节数据：权值高的数据，低字节数据：权值低的数据。即左高右低。

//面试题：判断当前计算机的大小端存储
//思路：拿出一个数的内存存储方式，判断第一个字节是与预期的结果是否一致
//假设：计算机中存储了int a = 1;即int a = 0x00000001;
//获取a的地址，强转为char*，从而访问第一个字节，判断如果是为00则是大端存储模式，如果是01则是小端存储模式
/*
#include <stdio.h>
//方法1：
int check_sys()
{
	int a = 1;
	//如果是大端存储，则存储方式是00 00 00 01，此时*(char*)&a返回的结果是0
	//如果是小端存储，则存储方式是01 00 00 00，此时*(char*)&a返回的结果是1

	//根据存储的数据，设计返回值
	//返回值为0，表示大端
	//返回值为1，表示小端
	return *(char*)&a;
}
//方法2：
//思路：使用共用体类型，对int类型成员赋值，对char类型成员取值，判断取出的值是与预期的结果是否一致
int check_sys()
{
	//union Un
	//{
	//	char c;
	//	int i;
	//}u;
	union		//可以用匿名联合体，因为该联合体用一次之后就不用了
	{
		char c;
		int i;
	}u;//匿名联合体声明的同时定义的联合体变量
	u.i = 1;//对共用存储块的i进行赋值，
	//如果是大端存储，则存储方式是00 00 00 01，此时的成员变量c结果是0
	//如果是小端存储，则存储方式是01 00 00 00，此时的成员变量c结果是1
	
	//根据存储的数据，设计返回值
	//返回值为0，表示大端
	//返回值为1，表示小端
	return u.c;
}
int main()
{
	int ret = check_sys();
	if (1 == ret)
		printf("小端");
	else
		printf("大端");
	return 0;
}
*/

//3、联合大小的计算
//联合体类型大小的计算规则：
/*********************************************************************************************
//1、联合的大小至少是最大成员的大小。

//2、当最大成员大小不是最大对齐数(每个成员变量的对齐数中最大对齐数)的整数倍的时候，就要对齐到最大对齐数的整数倍。
//注意：
//计算联合体总大小时，先(按1规则)计算出联合体总大小，再(按2)判断总大小是不是“为每个成员变量的对齐数中最大对齐数”的整数倍。
//若是，则取该大小为联合体大小；
//若不是，则取“每个成员变量的对齐数中最大对齐数”的整数倍，(前提至少能容纳所有成员的空间)满足条件下的最小值。
**********************************************************************************************/
/*
#include <stdio.h>
union Un1
{
	char c[5];//占5个字节，对齐数是1
	int i;//占4个字节，对齐数是4
	//联合体总大小：至少为5字节，但是需要对齐到最大对齐数4的整数倍，即需要8字节
};
union Un2
{
	short c[7];//占7个字节，对齐数是2
	int i;//占4个字节，对齐数是4
	//联合体总大小：至少为14字节，但是需要对齐到最大对齐数4的整数倍，即需要16字节
};
int main()
{
	//下面输出的结果是什么？
	union Un1 u;
	printf("%d\n", sizeof(u));
	printf("%d\n", sizeof(union Un1));//8
	printf("%d\n", sizeof(union Un2));//16
}
*/
//最后总结：
//结构体存在内存对齐，位段不存在内存对齐，枚举不存在内存对齐，联合体存在内存对齐

//四、通讯录程序
//见项目"Contact"：test.c、contact.c、contact.h
//test.c测试
//contact.c实现函数的功能
//contact.h声明函数