#define _CRT_SECURE_NO_WARNINGS 1
//自定义类型：结构体、枚举、联合
//一、结构体
//1、结构体类型的声明
//结构的基础知识：结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。

//声明结构体类型的格式
//struct tag结构体名称
//{
//	member - list//成员变量声明列表
//}variable-list;//结构体变量列表;

//声明一个结构体类型
//例如描述一个学生：声明一个学生类型，想通过学生类型来创建学生变量(对象)
//描述学生：属性+名字+电话+性别+年龄...
//#include <stdio.h>
//struct Stu
//{
//	char name[20];//名字
//	int age;//年龄
//	char sex[5];//性别
//	char id[20];//学号
//}s4, s5, s6; //声明结构体类型并创建结构体变量s4,s5,s6，均为全局变量，且分号不能丢
//
//struct Stu s3;//全局变量s3
//int main()
//{
//	//创建结构体局部变量s1,s2
//	struct Stu s1;
//	struct Stu s2;
//  return 0;
//}

//特殊的声明
//在声明结构的时候，可以不完全的声明。

//匿名结构体类型
//#include <stdio.h>
//struct
//{
//	int a;
//	char b;
//	float c;
//}x;//匿名结构体变量x
//struct
//{
//	int a;
//	char b;
//	float c;
//}a[20], *p;//匿名结构体数组，匿名结构体指针
////上面的两个结构在声明的时候由于省略掉了结构体标签（tag）。
////只能通过声明结构体类型的同时创建结构体变量
//int main()
//{
//	p = &x;//尽管成员变量是相同的，但编译器会把上面的两个声明当成完全不同的两个类型。会报警告
//
//	return 0;
//}

//2、结构的自引用
//数据结构：数据在内存种的存储方式的结构
//如：链表通过结点将分布在内存不同地方的数据联系在一起的结构，此时为了实现联系，即结构体找到同类型的其他变量
//每个结点一部分存数据，一部分存执行下一个结点的地址，最后一个结点存NULL空指针，即数据域+指针域
//struct Node
//{
//	int data;
//	//链表方式的错误实现
//	//struct Node n;//结构体类型的成员变量不能包含本身结构体类型的变量
//	
//	//链表方式的正确实现
//	struct Node* next;
//};
 
//结构体类型的重命名
//#include <stdio.h>
//typedef struct Node
//{
//	int data;
//	struct Node* next;
//}Node;
//int main()
//{
//	struct Node n1;
//	Node n2;
//	return 0;
//}

//这种书写方式是错误的，由于Node的使用在声明之前
//typedef struct
//{
//	int data;
//	Node* next;
//}Node;

//3、结构体变量的定义和初始化
//struct Point
//{
//	int x;
//	int y;
//}p1; //声明类型的同时定义变量p1
//struct Point p2; //定义结构体变量p2

//#include <stdio.h>
//struct T
//{
//	double weight;
//	short age;
//};
//struct S
//{
//	char c;
//	struct T st;
//	int a;
//	double d;
//	char arr[20];
//}s1 = { 'c',{ 55.6, 30 },100,3.14,"hello bit" };//结构体嵌套初始化
//struct S s2= { 'c',{ 55.6, 30 },100,3.14,"hello bit" };//结构体嵌套初始化
//int main()
//{
//	//结构体嵌套初始化
//	struct S s = { 'c',{ 55.6, 30 },100,3.14,"hello bit" };//定义结构体变量s，并初始化
//	//访问成员变量
//	printf("%c %d %lf %s\n", s.c, s.a, s.d, s.arr);
//	printf("%lf\n", s.st.weight);
//	return 0;
//}

//4、结构体内存对齐
//如何计算结构体类型的所占空间的大小？
//首先得掌握结构体的对齐规则：
//1. 第一个成员总是在与结构体变量偏移量为0的地址处。

//2. 其他成员变量要对齐到某个数字（或对齐数）的整数倍的地址处。即偏移量为某个数字（或对齐数）的整数倍的地址处

//对齐数 = 编译器默认的一个对齐数 与 该成员所占空间大小的较小值。
//VS中默认的值为8
//gcc编译器，没有默认对齐数，即对齐数选择该成员大小作为对齐数

//3. 结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。

//4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。

//#include <stdio.h>
//struct S1
//{
//	char c1;//c1存放方式：放在结构体变量偏移量为0的地址处
//	int a;//a存放方式：所占空间大小为4与编译器对齐数8比较，选4，即放在4的整数倍的地址处
//	char c2;//c2存放方式：所占空间大小为1与编译器的对齐数8比较，选1，即放在1的整数倍的地址处
//	//结构体所占空间的总大小：选各成员变量中的最大对齐数（1，4，1）选4，即结构体所占空间的总大小为4的整数倍
//};
//struct S2
//{
//	char c1;
//	char c2;
//	int a;
//};
//int main()
//{
//	//将成员变量的第一个变量初始化为0，其余按默认方式初始化为0
//	struct S1 s1 = { 0 };
//	printf("%d\n", sizeof(s1));
//	struct S1 s2 = { 0 };
//	printf("%d\n", sizeof(s2));
//	return 0;
//}

//练习3
//#include <stdio.h>
//struct S3
//{
//	double d;0-7
//	char c;8  9-11
//	int i;12-15  0-15一共16个字节，由于16是最大对齐数的整数倍，所以S3的大小就是16字节
//};
//练习4
//struct S4
//{
//	char c1;//c1存放方式：放在结构体变量偏移量为0的地址处
//	struct S3 s3;//s3的存放方式：嵌套的结构体对齐到自己的最大对齐数的整数倍处，即放在8的整数倍的地址处
//	double d;//d的存放方式：所占空间大小为8与编译器对齐数8比较，选8，即放在8的整数倍的地址处
//	//此时结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。即8的整数倍
//};
//int main()
//{
//	printf("%d\n", sizeof(struct S3));//8+1+3+4 = 16，由于总大小为8的倍数，故总大小为16字节
//	//结构体嵌套问题
//	printf("%d\n", sizeof(struct S4));//1+7+16+8 = 32，由于总大小为8的倍数，故总大小为32字节
//	return 0;
//}

//为什么存在内存对齐?
//原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。
//结构体的内存对齐是拿空间来换取时间的做法。--类似计组中的数据在内存中的存储

//那在设计结构体的时候，我们既要满足对齐，又要节省空间，如何做到：让占用空间小的成员尽量集中在一起。
//如：S1和S2类型的成员一模一样，但是S1和S2所占空间的大小有了一些区别。
//struct S1
//{
//	char c1;
//	int i;
//	char c2;
//};
//struct S2
//{
//	char c1; //让占用空间小的成员c1和c2尽量集中在一起。
//	char c2;
//	int i;
//};

//修改默认对齐数
//#include <stdio.h>
//#pragma pack(4)//设置默认对齐数为4
//struct S
//{
//	char c;
//	double d;
//	//对齐数为8时：1 + 7 + 8 = 16
//	//对齐数为4时：1 + 3 + 8 = 12
//	//对齐数为1时：1 + 8 = 9//会导致访问数据两次，增加了处理的时间
//};
//#pragma pack()//取消设置的默认对齐数
////若存在多个#pragma pack (n),遵从向上对齐原则，即某个结构体定义上方最近的一个#pragma pack（）
//int main()
//{
//	struct S s;
//	printf("%d\n", sizeof(s));
//	return 0;
//}

//offsetof()用于计算结构体成员相对于结构体的偏移量大小
//offsetof()是宏，不是函数
//查看手册，了解使用规则size_t offsetof(structName,memberName);
//#include <stdio.h>
//#include <stddef.h>
//struct S
//{
//	char c;
//	int i;
//	double d;
//};
//int main()
//{
//	printf("%d\n", offsetof(struct S, c));//0
//	printf("%d\n", offsetof(struct S, i));//4
//	printf("%d\n", offsetof(struct S, d));//8
//	return 0;
//}

//百度笔试题：
//写一个宏，计算结构体中某变量相对于首地址的偏移，并给出说明
//考察： offsetof 宏的实现
//注：这里还没学习宏，可以放在宏讲解完后再实现。

//5、结构体传参
//#include <stdio.h>
//struct S
//{
//	int a;
//	char c;
//	double d;
//};
//传值调用：不改变值的大小
//void Init(struct S tmp)
//{
//	tmp.a = 100;
//	tmp.c = 'w';
//	tmp.d = 3.14;
//}
//由于值传递，形参tmp是实参的一份临时拷贝，拥有各自独立的空间，改变了tmp的空间的值，但不会改变实参的结果

//传址调用:函数内部想改变函数外部变量的值，使用传址调用
//void Init(struct S *tmp)
//{
//	/*(*tmp).a = 100;
//	(*tmp).c = 'w';
//	(*tmp).d = 3.14;*/
//	tmp->a = 100;
//	tmp->c = 'w';
//	tmp->d = 3.14;
//}
////传值
//void Print1(struct S tmp)
//{
//	printf("%d %c %lf\n", tmp.a, tmp.c, tmp.d);
//}
////传址
//void Print2(const struct S *ps)//由于只希望打印而不希望改变值，加上const更安全
//{
//	printf("%d %c %lf\n", ps->a, ps->c, ps->d);
//}
////传值调用方式：当传入的变量过多时，占用的内存资源更多。
//int main()
//{
//	struct S s = { 0 };
//	//1、初始化
//	/*s.a = 100;
//	s.c = 'w';
//	s.d = 3.14;*/
//
//	//2、自定义初始化结构体成员变量的函数
//	//Init(s);
//	Init(&s);
//	Print1(s);
//	Print2(&s);
//	/*上面的 print1 和 print2 函数哪个好些？
//		答案是：首选print2函数。
//		原因：
//		函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销。
//		如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的
//		下降。*/
//  //结论：结构体传参的时候，要传结构体的地址。
//	return 0;
//}

//6、结构体实现位段（位段的填充 & 可移植性）
//什么是位段
//位段的声明和结构是类似的，有两个不同：
//1.位段的成员必须是 int、unsigned int 或signed int 。
//2.位段的成员名后边有一个冒号和一个数字。

//位段的内存分配
//1. 位段的成员可以是 int unsigned int signed int 或者是 char （属于整形家族）类型
//2. 位段的空间上是按照需要以4个字节（ int ）或者1个字节（ char ）的方式来开辟的。
//即如果存储的数据空间不足，则再开辟一个int或char大小的空间来存储数据
//3. 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。
//#include <stdio.h>
//struct S//S是位段类型
//{
//	int a : 2;//a只需要占2个bit位
//	int b : 5;//b只需要占5个bit位
//	int c : 10;//c只需要占10个bit位
//	int d : 30;//d只需要占30个bit位
//	//位的大小不能超过32
//};
//int main()
//{
//	struct S s;
//	printf("%d\n", sizeof(s));
//	//给位段分配一个int字节的空间，存放a，b，c，由于剩余15个bit位不够存储d，被浪费掉
//	//于是再分配一个int字节的空间，存放d
//	//故位段变量s的空间大小是8字节
//}
//定义int类型的变量，本来需要4个字节存储，但是如果使用位段，则存储数据只需要适应的位的大小，从而节省了空间
//位段的作用：节省空间
//#include <stdio.h>
//struct S
//{
//	char a : 3;
//	char b : 4;
//	char c : 5;
//	char d : 4;
//	//位的大小不能超过8
//};
//int main()
//{
//	struct S s;
//	printf("%d\n", sizeof(s));
//	//给位段分配一个char字节的空间，存放a，b由于剩余1个bit位不够存储c，被浪费掉
//	//于是再分配一个char字节的空间，存放c，由于剩余3个bit位不够存储d，被浪费掉
//	//于是再分配一个char字节的空间，存放d
//	//故位段变量s的空间大小是3字节
//}
//int main()
//{
//	struct S s = { 0 };
//	s.a = 10;//00001010 - 只需要3个bit位即010
//	s.b = 20;//00010100 - 只需要4个bit位即0100
//	s.c = 3;// 00000011 - 只需要5个bit位即00011
//	s.d = 4;// 00000100 - 只需要4个bit位即0100
//	//空间是如何开辟的
//	//假设位段存放的方式：先使用低位的bit位再使用高位bit位
//	//低地址                       高地址
//	//   b    a          c           d
//	//0 0000 000 | 000 00000 | 0000 0000
//	//0 0100 010   000 00011   0000 0100    
//	//十六进制：0x220304
//	//调试-窗口-内存，查看&s发现，在VS中位段存放的方式是先使用低位的bit位再使用高位bit位
//	//3. 位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。
//	//由于C语言标准没有规定位段的存储方式，不同的编译器对位段存储的实现方式也不相同，导致不能跨平台性
//}

//位段的跨平台问题
//1. int 位段被当成有符号数还是无符号数是不确定的。
//2. 位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出问题。但在32位机器是正常的）
//3. 位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。
//4. 当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的。
//总结：
//跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在。

//位段的应用
//如：数据的传输，对数据包添加很多信息，使用位段就能很好的利用空间

//二、枚举
//枚举顾名思义就是一一列举。把可能的取值一一列举。
//比如我们现实生活中：
//一周的星期一到星期日是有限的7天，可以一一列举。
//性别有：男、女、保密，也可以一一列举。
//月份有12个月，也可以一一列举

//1、枚举类型的定义
//#include <stdio.h>
//enum Day//星期
//{
//	//枚举的可能取值-他们是常量，可以对其赋初值，不赋初值时默认值从0依次递增
//	//但赋初值后，值不能被修改
//	Mon,
//	Tues = 5,
//	Wed,
//	Thur,
//	Fri,
//	Sat,
//	Sun
//};

//2、枚举的使用
//enum Sex//性别
//{
//	//枚举的可能取值-他们是常量，可以对其赋初值，不赋初值时默认值从0依次递增
//	//但赋初值后，值不能被修改
//	MALE = 2,
//	FEMALE = 4,
//	SECRET = 8
//};
//enum Color//颜色
//{
//	//枚举的可能取值-他们是常量，可以对其赋初值，不赋初值时默认值从0依次递增
//	//但赋初值后，值不能被修改
//	RED,
//	GREEN,
//	BLUE
//};
////以上声明的 enum Day ， enum Sex ， enum Color 都是枚举类型。
////{  }中的内容是枚举类型的可能取值，也叫 枚举常量 。
////这些可能取值都是有值的，默认从0开始，一次递增1，当然在定义的时候也可以赋初值。
//int main()
//{
//	//定义枚举变量并赋初值
//	enum Sex s = MALE;
//	enum Color c = BLUE;
//	//只能那枚举常量给枚举变量赋初值，否则会出现类型差异
//	//enum Color c = 2;//cpp中报错："初始化":无法从"int"转换为"Color"，不
//	//MALE = 0;报错
//	printf("%d %d %d\n", RED, GREEN, BLUE);
//	printf("%d %d %d\n", MALE, FEMALE, SECRET);
//	return 0;
//}

//3、枚举的优点
//为什么使用枚举？
//我们可以使用 #define 定义常量，为什么非要使用枚举？
//枚举的优点：
//1. 增加代码的可读性和可维护性
//2. 和#define定义的标识符比较，枚举有类型检查，更加严谨。
//3. 防止了命名污染（封装）
//4. 便于调试
//5. 使用方便，一次可以定义多个常量

//4、计算枚举类型的变量大小
//#include <stdio.h>
//enum Sex//性别
//{
//	MALE = 2,
//	FEMALE = 4,
//	SECRET = 8
//};
//int main()
//{
//	
//	enum Sex s = MALE;//即相当于把整型赋给了s
//	//故枚举变量的大小是int型的大小
//	printf("%d\n", sizeof(s));
//	return 0;
//}

//三、联合(联合体、共用体)
//联合也是一种特殊的自定义类型
//这种类型定义的变量也包含一系列的成员，特征是这些成员公用同一块空间（所以联合也叫共用体）。
//1、联合类型的定义
//#include <stdio.h>
//union Un//联合类型的声明
//{
//	char c;
//	int i;
//};
//int main()
//{
//	//联合变量的定义
//	union Un u;
//	//计算联合变量的大小
//	printf("%d\n", sizeof(u));
//	printf("%p\n", &u);
//	printf("%p\n", &(u.c));
//	printf("%p\n", &(u.i));
//	//通过结果发现，地址相同
//	//分析：
//	//由于联合成员变量c和i共用同一块空间，c占用该空间的1个字节，i占用该空间的4个字节
//	//c和i首地址相同，共享1个字节的大小
//  return 0;
//}

//2、联合的特点
//联合的成员是共用同一块内存空间的，这样一个联合变量的大小，至少是最大成员的大小（因为联
//合至少得有能力保存最大的那个成员）。
//#include <stdio.h>
//union Un
//{
//	int i;
//	char c;
//};
//int main()
//{
//	union Un un;
//	// 下面输出的结果是一样的吗？
//	printf("%d\n", &(un.i));
//	printf("%d\n", &(un.c));
//	//下面输出的结果是什么？
//	un.i = 0x11223344;
//	un.c = 0x55;
//	printf("%x\n", un.i);
//	return 0;
//}
//注意：联合变量不能同时使用，否则会改变另外一个变量

//面试题：判断当前计算机的大小端存储
//思路：拿出一个数的内存存储方式，判断第一个字节是与预期的结果是否一致
//假设：计算机中存储了int a = 1;即int a = 0x00000001
//拿出第一个字节，判断如果是为00则是大端存储模式，如果是01则是小端存储模式
//#include <stdio.h>
//int check_sys()
//{
//	int a = 1;
//	//根据存储的数据，设计返回值
//	//返回值为1，表示大端
//	//返回值为0，表示小端
//	return *(char*)&a;
//}
//int main()
//{
//	int a = 1;
//	int ret = check_sys();
//	if (1 == ret)
//		printf("小端");
//	else
//		printf("大端");
//	return 0;
//}

//#include <stdio.h>
//int check_sys()
//{
//	union Un//可以用匿名联合体
//	{
//		char c;
//		int i;
//	}u;
//	u.i = 1;//对共用存储块的i进行赋值，
//	//如果是大端存储，则存储方式是00 00 00 01，此时的成员变量c结果是0
//	//如果是小端存储，则存储方式是01 00 00 00，此时的成员变量c结果是1
//	
//	//根据存储的数据，设计返回值
//	//返回值为1，表示大端
//	//返回值为0，表示小端
//	return u.c;
//}
//int main()
//{
//	int ret = check_sys();
//	if (1 == ret)
//		printf("小端");
//	else
//		printf("大端");
//	return 0;
//}

//3、联合大小的计算
//联合的大小至少是最大成员的大小。
//当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍。
//#include <stdio.h>
//union Un1
//{
//	char c[5];//占5个字节，对齐数是1
//	int i;//占4个字节，对齐数是4
//};
//union Un2
//{
//	short c[7];//占7个字节，对齐数是2
//	int i;//占4个字节，对齐数是4
//};
//int main()
//{
//	//下面输出的结果是什么？
//	union Un1 u;
//	printf("%d\n", sizeof(u));
//	printf("%d\n", sizeof(union Un1));//至少为5字节，但是需要对齐到最大对齐数4的整数倍，即需要8字节
//	printf("%d\n", sizeof(union Un2));//至少为14字节，但是需要对齐到最大对齐数4的整数倍，即需要16字节
//}

//通讯录程序
//详见：
//Contact文件夹
//test.c测试
//contact.c实现函数的功能
//contact.h声明函数