#define _CRT_SECURE_NO_WARNINGS 1

//9. 指针和数组面试题的解析
#include <stdio.h>
#include <string.h>
//int main()
//{
//	//一维数组
//	int a[] = { 1,2,3,4 };
//	printf("%d\n", sizeof(a));//16 - 数组名表示整个数组，计算的是数组的总大小
//	printf("%d\n", sizeof(a + 0));//4/8 - 数组名是首元素的地址，a+0还是首元素地址
//	//数组名是首元素的地址，除以下两种外：
//	//1、sizeof(数组名) - 数组名表示整个数组
//	//2、&数组名 - 数组名表示整个数组
//	printf("%d\n", sizeof(*a));//4 - 数组名是首元素的地址，*a就是首元素
//	printf("%d\n", sizeof(a + 1));//4/8 - 数组名是首元素的地址，a+1就是第二个元素的地址
//	printf("%d\n", sizeof(a[1]));//4 - 第二个元素的大小
//	printf("%d\n", sizeof(&a));//4/8 - 数组名表示整个数组，&a是数组的地址，计算的是地址的大小
//	printf("%d\n", sizeof(*&a));//16 - 数组名表示整个数组，&a是数组的地址，*&a取数整个数组，计算的是数组的大小，即&和*相互抵消
//	printf("%d\n", sizeof(&a + 1));//4/8 - 数组名表示整个数组，&a是数组的地址，&a+1下一个数组的地址，计算的是地址的大小
//	printf("%d\n", sizeof(&a[0]));//4/8 - &a[0]首元素的地址
//	printf("%d\n", sizeof(&a[0] + 1));//4/8 - &a[0]+1第二个元素的地址
//	//字符数组
//	char arr[] = { 'a','b','c','d','e','f' };
//	printf("%d\n", sizeof(arr));//6 - 数组名表示整个数组，计算的是数组的总大小
//	printf("%d\n", sizeof(arr + 0));//4/8 - 数组名是首元素的地址，arr+0还是首元素地址
//	printf("%d\n", sizeof(*arr));//1
//	printf("%d\n", sizeof(arr[1]));//1
//	printf("%d\n", sizeof(&arr));//4/8
//	printf("%d\n", sizeof(&arr + 1));//4/8
//	printf("%d\n", sizeof(&arr[0] + 1));//4/8
//
//	printf("%d\n", strlen(arr));//随机值 - 首元素地址往后数，直到遇到'\0'
//	printf("%d\n", strlen(arr + 0));//随机值 - 数组名是首元素的地址，arr+0还是首元素地址，
//	printf("%d\n", strlen(*arr));//error 非法访问，程序崩溃，*arr首元素 - 'a' = 97，将97当成地址往访问(strlen(const char* str)参数接收的是地址)，直到遇到'\0'
//	printf("%d\n", strlen(arr[1]));//error 非法访问，程序崩溃，把98当作地址往访问
//	printf("%d\n", strlen(&arr));//随机值 - &arr数组的地址，往后数，直到遇到'\0'
//	printf("%d\n", strlen(&arr + 1));//随机值-6 - &arr+1下一个数组的地址，往后数，直到遇到'\0'(与上面的随机值差6)
//	printf("%d\n", strlen(&arr[0] + 1));//随机值-1 - &arr[0] + 1第二个元素的地址，往后数，直到遇到'\0'(与上面的随机值差1)
//}

//int main()
//{
//	char arr[] = "abcdef";
//	printf("%d\n", sizeof(arr));//7
//	printf("%d\n", sizeof(arr + 0));//4/8
//	printf("%d\n", sizeof(*arr));//1
//	printf("%d\n", sizeof(arr[1]));//1
//	printf("%d\n", sizeof(&arr));//4/8
//	printf("%d\n", sizeof(&arr + 1));//4/8
//	printf("%d\n", sizeof(&arr[0] + 1));//4/8
//
//	printf("%d\n", strlen(arr));//6 - 首元素地址往后数，直到遇到'\0'
//	printf("%d\n", strlen(arr + 0));//6 - 数组名是首元素的地址，arr+0还是首元素地址，往后数，直到遇到'\0'
//	printf("%d\n", strlen(*arr));//error 非法访问，程序崩溃，*arr首元素 - 'a' = 97，将97当成地址往后数，直到遇到'\0'，即读取位置0x00000061 = 97时发生访问冲突
//	printf("%d\n", strlen(arr[1]));//error 非法访问，程序崩溃
//	printf("%d\n", strlen(&arr));//6 - &arr数组的地址，应该存入数组指针char (*p)[7]中，编译会发生警告
//	printf("%d\n", strlen(&arr + 1));//随机值 - &arr + 1下一个数组的地址，（已经跳过了'\0'）
//	printf("%d\n", strlen(&arr[0] + 1));//5 - 从第二个字符地址往后数，直到遇到'\0'
//
//	char* p = "abcdef";//把首元素a的地址放入p中
//	printf("%d\n", sizeof(p));//4/8 - 计算指针变量(首元素a的地址)的大小
//	printf("%d\n", sizeof(p + 1));//4/8 - 计算第二个字符b的地址大小
//	printf("%d\n", sizeof(*p));//1 - 计算*p字符a的大小 
//	printf("%d\n", sizeof(p[0]));//1 - 计算p[0]=*(p+0)字符a的大小
//	printf("%d\n", sizeof(&p));//4/8 - 计算p的地址大小
//	printf("%d\n", sizeof(&p + 1));//4/8
//	printf("%d\n", sizeof(&p[0] + 1));//4/8
//
//	printf("%d\n", strlen(p));//6 - p即'a'地址往后数，直到遇到'\0'
//	printf("%d\n", strlen(p + 1));//5 - p+1即'b'地址往后数，直到遇到'\0'
//	printf("%d\n", strlen(*p));//error 非法访问，程序崩溃，*p = 'a' = 97,将97当成地址往后数，直到遇到'\0'，即读取位置0x00000061 = 97时发生访问冲突
//	printf("%d\n", strlen(p[0]));//error 非法访问，程序崩溃
//	printf("%d\n", strlen(&p));//随机值 - 从p的地址往后数
//	printf("%d\n", strlen(&p + 1));//随机值
//	printf("%d\n", strlen(&p[0] + 1));//5 - &p[0] + 1即字符b的地址往后数，直到遇到'\0'
//}

//int main()
//{
//	//二维数组
//	int a[3][4] = { 0 };
//	//a[3][4]
//	//a[0]：[  ][  ][  ][  ]
//	//a[1]：[  ][  ][  ][  ]
//	//a[2]：[  ][  ][  ][  ]
//	printf("%d\n", sizeof(a));//3 * 4 * (4个字节) = 48 - a数组名表示整个数组，即计算整个数组的大小
//	printf("%d\n", sizeof(a[0][0]));//4 - a[0][0]是第一行第一个元素
//	printf("%d\n", sizeof(a[0]));//4 * (4个字节) = 16，a[0]相当于第一行作为一维数组的数组名， 此时表示一维数组整个数组，sizeof(a[0])则计算的是第一行的大小
//	printf("%d\n", sizeof(a[0] + 1));//4/8 - a[0]数组名，没有sizeof(数组名)，也没有&数组名，此时表示第一行的首元素地址，a[0] + 1第一行第二个元素的地址
//	//printf("%p\n",&a[0][0]);printf("%p\n",a[0]+1);
//	printf("%d\n", sizeof(*(a[0] + 1)));//4 - *(a[0] + 1))第一行第二个元素
//	
//	printf("%d\n", sizeof(a + 1));//4/8 - 没有sizeof(数组名)，也没有&数组名，a是数组名，是首元素地址，由于二维数组的首元素地址是一维数组(第一行)的地址(把二维数组看成一维数组)，a+1是第二行(一维数组)的地址 
//	//printf("%p\n",&a[0][0]);printf("%p\n",a+1);
//	printf("%d\n", sizeof(*(a + 1)));//16 - a + 1是第二行（一维数组）的地址，*(a + 1)即sizeof(a[1])第二行的大小
//	printf("%d\n", sizeof(&a[0] + 1));//4/8 - a[0]是第一行(一维数组)的数组名,&a[0]第一行(一维数组)的地址，&a[0] + 1是第二行(一维数组)的地址
//	//printf("%p\n", a + 1);printf("%d\n", sizeof(&a[0] + 1));
//
//	printf("%d\n", sizeof(*(&a[0] + 1)));//16 - *(&a[0] + 1)是第二行的大小
//	printf("%d\n", sizeof(*a));//16 - a是首元素的地址，即第一行的地址，*a是第一行(一维数组)
//	printf("%d\n", sizeof(a[3]));//16 - a[3]第四行的数组名，但是sizeof()中不做真实计算，只是根据类型计算大小
//	return 0;
//}
//总结：
//数组名的意义：
//1. sizeof(数组名)，这里的数组名表示整个数组，计算的是整个数组的大小。
//2. & 数组名，这里的数组名表示整个数组，取出的是整个数组的地址。
//3. 除此之外所有的数组名都表示首元素的地址。
//4. strlen只能求字符数组的长度，不能求整型数组的长度

//10. 指针笔试题
//笔试题1：
//int main()
//{
//    int a[5] = { 1, 2, 3, 4, 5 };
//    int* ptr = (int*)(&a + 1);//将&a+1的整型数组指针强制类型转换成整型指针
//    printf("%d,%d", *(a + 1), *(ptr - 1));//2 5，整型指针-1，向前跳过一个整型
//    return 0;
//}
//程序的结果是什么？

//笔试题2：
//由于还没学习结构体，这里告知结构体的大小是20个字节
//struct Test
//{
//    int Num;
//    char* pcName;
//    short sDate;
//    char cha[2];
//    short sBa[4];
//}* p;//结构体指针变量p
////假设p 的值为0x100000。 如下表表达式的值分别为多少？
////已知，结构体Test类型的变量大小是20个字节
//int main()
//{
//    p = (struct Test*)0x100000;//初始化地址0x100000，是一个整数，需要强制类型转换，否则会报警告
//    //指针+1，跳过p指针类型个字节
//    printf("%p\n", p + 0x1);//结构体指针p+1 = p + 20 = 0x00100000 + 0x00000014 = 0x00100014(地址跳过结构体类型的大小)
//    printf("%p\n", (unsigned long)p + 0x1);//将地址转换为整型类型，p + 1 = 1048576 + 1 = 1048577 = 0x100001(数字跳过整型大小)
//    printf("%p\n", (unsigned int*)p + 0x1);//将地址转换为整型指针类型p + 4 = 0x00100000 + 0x00000004 = 0x00100004(地址跳过整型的大小)
//    //%p，将该数的补码当作无符号数打印
//    return 0;
//}

//笔试题3：
//int main()
//{
//    int a[4] = { 1, 2, 3, 4 };
//    int* ptr1 = (int*)(&a + 1);
//    int* ptr2 = (int*)((int)a + 1);
//    printf("%x,%x", ptr1[-1], *ptr2);
//    //%x，十六进制打印
//    //a[4]在内存的存储：           低地址                                       高地址
//    // 由于当前机器是小端存储模式：01 00 00 00|02 00 00 00|03 00 00 00|04 00 00 00
//    //int(*)(&a+1) == ptr1                                                        |ptr1
//    //(int*)((int)a + 1) == ptr2      |ptr2
//    //                                                                 ptr1[-1]
//    //                                |*ptr2
//    //ptr1[-1] = *(ptr1+(-1))，由于ptr1是整型指针，故指针-1，向前跳整型大小，解引用得到一个整型字节大小，即00 00 00 04 = 0x4
//    //*ptr2,由于ptr2是整型指针，故解引用访问整型个字节大小，即02 00 00 00 = 0x2000000
//    return 0;
//}

//笔试题4：
//#include <stdio.h>
//int main()
//{
//    int a[3][2] = { (0, 1), (2, 3), (4, 5) };//逗号表达式，即int a[3][2] = { 1, 3, 5 }
//    int* p;
//    p = a[0];
//    printf("%d", p[0]);
//    //int a[3][2]
//    //a[0] [ 1 ][ 3 ]
//    //     [ 5 ][ 0 ]
//    //     [ 0 ][ 0 ]
//    //a[0]是第一行的数组名，没有那两种情况，表示首元素的地址，即p存的是1的地址
//    //p[0] = *(p+0) = 1
//    return 0;
//}

//笔试题5：
//int main()
//{
//    int a[5][5];
//    int(*p)[4];//p的类型是int(*)[4]
//    //a是二维数组名，表示首元素的地址，即一维数组(第一行)的地址a[0]
//    p = a;//a的类型是int(*p)[5]，故会报警告
//    printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
//    //低内存                                                                                                高内存
//    //[  ][  ][  ][  ][  ] |[  ][  ][  ][  ][  ] |[  ][  ][  ][  ][  ] |[  ][  ][  ][  ][  ] |[  ][  ][  ][  ][  ]  
//    //          a[0]                a[1]                 a[2]             a[3]                    a[4]     
//    //                |                 |                 |                 |                |
//    //p               p+1               p+2               p+3               p+4
//    //p[4][2] = *(*(p+4)+2)                                                         |p[4][2]          |a[4][2]    
//    //二维数组存储也是连续存放的
//    //&p[4][2] - &a[4][2] = -4
//    //%d - -4
//    //%p - 将该数的补码当作无符号数打印0xFF FF FF FC
//    return 0;
//}

//笔试题6：
//int main()
//{
//    int aa[2][5] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
//    //[][][][][]|[][][][][]
//    //|&aa                 |ptr1
//    //|aa        |ptr2
//    int* ptr1 = (int*)(&aa + 1);//&aa - 此时aa是整个数组，即整个数组的地址，需要数字指针保存，故强制类型转换
//    //&aa + 1，跳过整个数组
//    //强制类型转换，只是类型发生了改变，值不改变
//    int* ptr2 = (int*)(*(aa + 1));//aa是数组名，是一维数组首元素的地址，此时aa是第一行的地址
//    //*(aa + 1) = aa[1]，找到了第二行，即第二行的数组名aa[1]，第二行首元素6的地址，故可以不强制类型转换，是多余的代码
//    //aa + 1，跳过一行
//    printf("%d,%d", *(ptr1 - 1), *(ptr2 - 1));
//    //*(ptr1 - 1) - 跳过一个整型，即10的地址
//    //*(ptr2 - 1) - 跳过一个整型，即5的地址
//    return 0;
//}
//回顾
//int arr[10] = { 1,2,3,4,5 };
//int* p = arr;
//*(p + 2) = p[2] = *(arr + 2) = arr[2];

//笔试题7：
//#include <stdio.h>
//int main()
//{
//    char* a[] = { "work","at","alibaba" };//字符指针数组，每个字符指针存放字符串常量的首字符地址
//    char* *pa = a;//首元素的地址赋值给了pa，pa指向的元素是char*类型
//    //内存存储：a[]
//    // char* p1 = "work" 
//    // char* p2 = "at" 
//    // char* p3 = "alibaba"
//    // char* *pa = a = &p
//    //pa++，即跳过char*，
//    pa++;//跳过char*大小，即每个字符指针都是char*，故跳到下一个字符串
//    printf("%s\n", *pa);//at
//    return 0;
//}
//回顾
//int *p;
//p + 1;//跳过一个int大小
//char* *p;
//p + 1;//跳过一个cha*大小

//笔试题8：
//int main()
//{
//    char* c[] = { "ENTER","NEW","POINT","FIRST" };
//    char* *cp[] = { c + 3,c + 2,c + 1,c };
//    char** *cpp = cp;
//    printf("%s\n", **++cpp);//POINT
//    printf("%s\n", *-- * ++cpp + 3);//ER
//    printf("%s\n", *cpp[-2] + 3);//ST
//    printf("%s\n", cpp[-1][-1] + 1);//EW
//    return 0;
//}
//                          cp[]                  c[]
//                          cp[0]:c+3             c[0]     char*   -----> "ENTER"
//      cpp:char***         cp[1]:c+2             c[1]     char*   -----> "NEW"
//                          cp[2]:c+1             c[2]     char*   -----> "POINT"
//                          cp[3]:c               c[3]     char*   -----> "FIRST"
//cpp中存入cp的地址，cp中存入c+整数的地址，c中存入字符串的地址
//c+3指向c[3]的地址，c+2指向c[2]的地址，c+1指向c[1]的地址，c指向c[0]的地址
//1、**++cpp = *(*(++cpp)),cp是cp[]首元素的地址，cpp指向cp[0]的地址，++cpp指向cp[1]的地址，
//*(++cpp)，cp[1]地址解引用得到c+2，即得到c[2]的地址，*(*(++cpp))，c[2]的地址解引用，找到c[2]的首元素地址，往后数直到遇见'\0'
//2、*-- * ++cpp + 3 = *(--(*(++cpp)))+ 3，由于前面++cpp，故再++cpp指向cp[2]的地址，
//*(++cpp))，cp[2]的地址解引用，得到c+1，即得到c[1]的地址，--(*(++cpp))得到c，此时指向c[0],即得到了c[0]的地址，*(--(*(++cpp)))找到c[0]的首元素地址，
//*(--(*(++cpp)))+ 3，得到第四个字符的地址，往后数直到遇见'\0'
//3、*cpp[-2] + 3 = *(*(cpp-2))+3，由于前面cpp指向cp[2]的地址，cpp-2指向cp[0]的地址，
//*(cpp-2)，cp[0]的地址得到c+3，即得到c[3]的地址，*(*(cpp-2))，c[3]的地址解引用，找到c[3]的首元素地址，*(*(cpp-2))+3，得到第四个元素的地址，往后数，直到遇到'\0'
//4、cpp[-1][-1] + 1 = *(*(cpp-1)-1)+1，由于cpp没有发生变化，cpp仍指向cp[2]的地址，
//cpp-1指向cp[1]的地址，*(cpp-1)，cp[1]的地址解引用得到c+2，即得到c[2]的地址，*(cpp-1)-1，得到c+1，得到c[1]的地址，
//*(*(cpp-1)-1)，解引用c[1]的地址，找到c[1]的首元素地址，*(*(cpp-1)-1)，得到第二个字符的地址，往后数直到遇见'\0'