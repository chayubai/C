#define _CRT_SECURE_NO_WARNINGS 1
 
//9. 指针和数组面试题的解析
#include <stdio.h>
#include <string.h>
/*  
int main()
{
	//一维数组
	int a[] = { 1,2,3,4 };
	printf("%d\n", sizeof(a));//16 - 数组名表示整个数组，计算的是数组的总大小
	printf("%d\n", sizeof(a + 0));//4/8 - 数组名是首元素的地址，a+0还是首元素地址
	//数组名是首元素的地址，除以下两种外：
	//1、sizeof(数组名) - 数组名表示整个数组
	//2、&数组名 - 数组名表示整个数组
	printf("%d\n", sizeof(*a));//4 - 数组名是首元素的地址，*a就是首元素
	printf("%d\n", sizeof(a + 1));//4/8 - 数组名是首元素的地址，a+1就是第二个元素的地址
	printf("%d\n", sizeof(a[1]));//4 - 第二个元素的大小
	printf("%d\n", sizeof(&a));//4/8 - 数组名表示整个数组，&a是数组的地址，计算的是地址的大小
	printf("%d\n", sizeof(*&a));//16 - 数组名表示整个数组，&a是数组的地址，*&a取数整个数组解引用，计算的是数组的大小，即&和*相互抵消
	printf("%d\n", sizeof(&a + 1));//4/8 - 数组名表示整个数组，&a是数组的地址，&a+1下一个数组的地址，计算的是地址的大小
	printf("%d\n", sizeof(&a[0]));//4/8 - &a[0]首元素的地址
	printf("%d\n", sizeof(&a[0] + 1));//4/8 - &a[0]+1第二个元素的地址
	//字符数组
	char arr[] = { 'a','b','c','d','e','f' };
	printf("%d\n", sizeof(arr));//6 - 数组名表示整个数组，计算的是数组的总大小
	printf("%d\n", sizeof(arr + 0));//4/8 - 数组名是首元素的地址，arr+0还是首元素地址
	printf("%d\n", sizeof(*arr));//1 - 数组名是首元素的地址，*arr是首元素，计算的是首元素的大小
	printf("%d\n", sizeof(arr[1]));//1 - arr[1]是第二个元素
	printf("%d\n", sizeof(&arr));//4/8 - 数组名表示整个数组，&arr是整个数组的地址
	printf("%d\n", sizeof(&arr + 1));//4/8 - 数组名表示整个数组，&arr+1是下一个数组的地址
	printf("%d\n", sizeof(&arr[0] + 1));//4/8 - 第二个元素的地址

	printf("%d\n", strlen(arr));//随机值 - 首元素地址往后数，当前地址所指向的内容，直到遇到'\0'
	printf("%d\n", strlen(arr + 0));//随机值 - 数组名是首元素的地址，arr+0还是首元素地址，
	printf("%d\n", strlen(*arr));//error 非法访问，程序崩溃，*arr首元素 即'a' = 97，将97当成字符串起始地址访问(strlen(const char* str)参数接收的是地址)，直到遇到'\0'
	printf("%d\n", strlen(arr[1]));//error 非法访问，程序崩溃，把98当作地址往访问
	printf("%d\n", strlen(&arr));//随机值 - &arr数组的地址，往后数，直到遇到'\0'
	printf("%d\n", strlen(&arr + 1));//随机值 - &arr+1下一个数组的地址，往后数，直到遇到'\0'(与上面的随机值差6)
	printf("%d\n", strlen(&arr[0] + 1));//随机值 - &arr[0] + 1第二个元素的地址，往后数，直到遇到'\0'(与上面的随机值差1)
	return 0;
}
*/

/*
int main()
{
	char arr[] = "abcdef";
	printf("%d\n", sizeof(arr));//7
	printf("%d\n", sizeof(arr + 0));//4/8
	printf("%d\n", sizeof(*arr));//1
	printf("%d\n", sizeof(arr[1]));//1
	printf("%d\n", sizeof(&arr));//4/8
	printf("%d\n", sizeof(&arr + 1));//4/8
	printf("%d\n", sizeof(&arr[0] + 1));//4/8

	printf("%d\n", strlen(arr));//6 - 首元素地址往后数，直到遇到'\0'
	printf("%d\n", strlen(arr + 0));//6 - 数组名是首元素的地址，arr+0还是首元素地址，往后数，直到遇到'\0'
	printf("%d\n", strlen(*arr));//error 非法访问，程序崩溃，*arr首元素 - 'a' = 97，将97当成地址往后数，直到遇到'\0'，即读取位置0x00000061 = 97时发生访问冲突
	printf("%d\n", strlen(arr[1]));//error 非法访问，程序崩溃
	printf("%d\n", strlen(&arr));//6 - &arr数组的地址，应该存入数组指针char (*p)[7]中，编译会发生警告：const char* 与char (*p)[7]类型不兼容
	printf("%d\n", strlen(&arr + 1));//随机值 - &arr + 1下一个数组的地址，（已经跳过了'\0'），编译也会发生警告
	printf("%d\n", strlen(&arr[0] + 1));//5 - 从第二个字符地址往后数，直到遇到'\0'

	char* p = "abcdef";//把首元素a的地址放入p中
	printf("%d\n", sizeof(p));//4/8 - 计算指针变量(首元素a的地址)的大小
	printf("%d\n", sizeof(p + 1));//4/8 - 计算第二个字符b的地址大小
	printf("%d\n", sizeof(*p));//1 - 计算*p字符a的大小 
	printf("%d\n", sizeof(p[0]));//1 - 计算p[0]=*(p+0)字符a的大小
	printf("%d\n", sizeof(&p));//4/8 - 计算p的地址大小
	printf("%d\n", sizeof(&p + 1));//4/8 - 指针变量的地址+1，计算的还是一个地址的大小
	printf("%d\n", sizeof(&p[0] + 1));//4/8 - 计算&p[0]+1字符b的地址大小

	printf("%d\n", strlen(p));//6 - p即'a'地址往后数，直到遇到'\0'
	printf("%d\n", strlen(p + 1));//5 - p+1即'b'地址往后数，直到遇到'\0'
	printf("%d\n", strlen(*p));//error 非法访问，程序崩溃，*p = 'a' = 97,将97当成地址往后数，直到遇到'\0'，即读取位置0x00000061 = 97时发生访问冲突
	printf("%d\n", strlen(p[0]));//error 非法访问，程序崩溃
	printf("%d\n", strlen(&p));//随机值 - 从p的地址往后数
	//比如:"abcdef"中a的地址是0x0012ff44,则p = 0x0012ff44，则p中的值在内存中的存储：44 ff 12 00
	//&p地址往后数，遇到0则结束，即strlen(&p) == 3
	//比如:"abcdef"中a的地址是0x1232ff44,则p = 0x1232ff44，则p中的值在内存中的存储：44 ff 32 12
	//&p地址往后数，遇到0则结束，即strlen(&p) == 随机值
	printf("%d\n", strlen(&p + 1));//随机值
	printf("%d\n", strlen(&p[0] + 1));//5 - &p[0] + 1即字符b的地址往后数，直到遇到'\0'
	return 0;
}
*/

/*
int main()
{
	//二维数组
	int a[3][4] = { 0 };
	//a[3][4]，可以将二维数组看成三个元素组成的一维数组，
	//每个元素又是一个一维数组，每个一维数组的数组名分别为a[0]、a[1]、a[2]
	//a[0]：[  ][  ][  ][  ]
	//a[1]：[  ][  ][  ][  ]
	//a[2]：[  ][  ][  ][  ]
	//注意：本质还是连续存放，只是把它想象成三行四列
	printf("%d\n", sizeof(a));//3 * 4 * (4个字节) = 48 - sizeof(数组名)，数组名a表示整个数组，即计算整个数组的大小
	printf("%d\n", sizeof(a[0][0]));//4 - a[0][0]是第一行第一个元素
	printf("%d\n", sizeof(a[0]));//4 * (4个字节) = 16
	//sizeof(数组名)，a[0]作为第一行一维数组的数组名， 数组名a[0]表示第一行一维数组整个数组，sizeof(a[0])则计算的是第一行的大小
	
	printf("%d\n", sizeof(a[0] + 1));//4/8
	//a[0]第一行一维数组的数组名，没有sizeof(数组名)，也没有&数组名，数组名a[0]表示第一行一维数组的首元素地址，a[0] + 1第一行第二个元素的地址
	//printf("%p\n",&a[0][0]);printf("%p\n",a[0]+1);//地址相差4字节
	printf("%d\n", sizeof(*(a[0] + 1)));//4
	//a[0]第一行一维数组的数组名,数组名a[0]表示第一行一维数组的首元素地址， *(a[0] + 1))第一行第二个元素
	
	printf("%d\n", sizeof(a + 1));//4/8 - 没有sizeof(数组名)，也没有&数组名
	//a是数组名，是首元素地址，由于二维数组的首元素地址是一维数组(第一行)的地址(把二维数组看成一维数组)，a+1是第二行(一维数组)的地址 
	//printf("%p\n",&a[0][0]);printf("%p\n",a+1);//地址相差16字节
	printf("%d\n", sizeof(*(a + 1)));//16 - a + 1是第二行（一维数组）的地址，*(a + 1)即sizeof(a[1])第二行的大小
	printf("%d\n", sizeof(&a[0] + 1));//4/8 - a[0]是第一行(一维数组)的数组名,&a[0]第一行(一维数组)的地址，&a[0] + 1是第二行(一维数组)的地址
	//printf("%p\n", a + 1);printf("%p\n", &a[0] + 1);//地址相同

	printf("%d\n", sizeof(*(&a[0] + 1)));//16 - *(&a[0] + 1)是第二行的大小
	printf("%d\n", sizeof(*a));//16 - a是首元素的地址，即第一行的地址，*a是第一行(一维数组)
	printf("%d\n", sizeof(a[3]));//16 - a[3]第四行的数组名，数组名表示第四行整个一维数组
	//注意：这里不报错，因为sizeof()中不做真实计算，不会出现越界访问，只是根据类型计算大小，
	return 0;
}
*/
//总结：
//数组名的意义：
//1. sizeof(数组名)，这里的数组名表示整个数组，计算的是整个数组的大小。
//2. &数组名，这里的数组名表示整个数组，取出的是整个数组的地址。
//3. 除此之外所有的数组名都表示首元素的地址。
//4. strlen只能求字符数组的长度，不能求整型数组的长度

//10. 指针笔试题
//笔试题1：
//程序的结果是什么？
/*
int main()
{
    int a[5] = { 1, 2, 3, 4, 5 };
    int* ptr = (int*)(&a + 1);//将&a+1的整型数组指针强制类型转换成整型指针
    printf("%d,%d", *(a + 1), *(ptr - 1));//2 5，整型指针-1，向前跳过一个整型
    return 0;
}
*/
//回顾：指针的意义
//整型指针+1，跳过一个整型大小
//字符型指针+1，跳过一个字符型大小
//数组指针+1，跳过一个数组大小
//整型指针解引用，访问一个整型大小空间
//字符型指针解引用，访问一个字符大小空间
//数组指针解引用，访问一个数组大小空间

//笔试题2：
//由于还没学习结构体，这里告知结构体的大小是20(32位)或32(64位)个字节
/*
#include <stddef.h> 
// - offsetof(structName,memberName) - #define offsetof(s,m) ((size_t)&(((s*)0)->m))
struct Test
{
    int Num;//0-3
    char* pcName;//4-7/8-15
    short sDate;//8-9/16-17
    char cha[2];//10-11/18-19
    short sBa[4];//12-19/20-27
}* p;//结构体指针变量p
//假设p 的值为0x100000。 如下表达式的值分别为多少？
//已知，结构体Test类型的变量大小是20(32位)或32(64位)个字节
int main()
{
	printf("%d\n", sizeof(struct Test));
	printf("%d\n", offsetof(struct Test, Num));//0 / 0
	printf("%d\n", offsetof(struct Test, pcName));//4 / 8
	printf("%d\n", offsetof(struct Test, sDate));//8 / 16
	printf("%d\n", offsetof(struct Test, cha));//10 / 18
	printf("%d\n", offsetof(struct Test, sBa));//12 / 20

    p = (struct Test*)0x100000;//初始化地址0x100000，0x100000是十六进制整数，需要强制类型转换为结构体指针，否则会报警告
    //指针+1，跳过一个结构体类型大小个字节
    printf("%p\n", p + 0x1);//结构体指针p+1(地址跳过结构体类型的大小) 即：p + 20 = 0x00100000 + 0x00000014 = 0x00100014
    printf("%p\n", (unsigned long)p + 0x1);//将地址转换为整型类型，0x100000的十进制为1048576,即：p + 1 = 1048576 + 1 = 1048577 = 0x00100001
	//也就是0x100000 + 1 = 0x100001
    printf("%p\n", (unsigned int*)p + 0x1);//将地址转换为整型指针类型，(p+1地址跳过整型的大小)p + 4 = 0x00100000 + 0x00000004 = 0x00100004
    
	//注意：强制类型转换，不会改变值的大小
	//%p，地址是一个无符号数，将该数的补码转为无符号数，再以原码打印
	//%x，以有符号十六进制原码打印，打印时，前面没有0. %p，打印时，前面有0

	//如果是64位：0x0000000000100020、0x0000000000100001、0x0000000000100004
    return 0;
}
*/

//笔试题3：
/*
int main()
{
    int a[4] = { 1, 2, 3, 4 };
    int* ptr1 = (int*)(&a + 1);
    int* ptr2 = (int*)((int)a + 1);//类似于上一题printf("%p\n", (unsigned long)p + 0x1);
	//假设a = 0x00000005 (int*)((int)a+1) = 5 + 1 = 0x00000006，相差1个字节
    printf("%x,%x", ptr1[-1], *ptr2);
    //%x，十六进制打印
    //a[4]在内存的存储：           低地址                                       高地址
    //由于当前机器是小端存储模式： 01 00 00 00|02 00 00 00|03 00 00 00|04 00 00 00
    //int(*)(&a+1) == ptr1                                                        |ptr1
    //(int*)((int)a + 1) == ptr2      |ptr2
    //                                                                |ptr1[-1]
    //                                |*ptr2     |
    //ptr1[-1] = *(ptr1+(-1))，由于ptr1是整型指针，故指针-1，向前跳整型大小，解引用得到一个整型字节大小，即0x00 00 00 04 
    //*ptr2,由于ptr2是整型指针，故解引用访问整型个字节大小，即0x02 00 00 00
	//结果为：4，2000000
	//注意：数据在计算机中的存储是二进制，为了研究方便，数据在内存中展示形式为十六进制
    return 0;
}
*/

//笔试题4：
/*
int main()
{
    int a[3][2] = { (0, 1), (2, 3), (4, 5) };//逗号表达式，即int a[3][2] = { 1, 3, 5 }
    int* p;
    p = a[0];
    printf("%d", p[0]);//a[0][0]
    //int a[3][2]
    //a[0] [ 1 ][ 3 ]
    //     [ 5 ][ 0 ]
    //     [ 0 ][ 0 ]
    //a[0]是第一行的数组名，没有那两种情况，数组名表示首元素的地址，即p存的是1的地址
    //p[0] = *(p+0) = 1
    return 0;
}
*/

//笔试题5：
/*
int main()
{
    int a[5][5];
    int(*p)[4];//p的类型是int(*)[4]，是一个数组指针，指向的数组有4个元素
    //a是二维数组名，表示首元素的地址，即一维数组(第一行)的地址a[0]
    p = a;//由于a的类型是int(*p)[5]，p的类型是int(*)[4]，类型不兼容，故会报警告
    printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
    //低内存                                                                                                高内存
    //[  ][  ][  ][  ][  ] |[  ][  ][  ][  ][  ] |[  ][  ][  ][  ][  ] |[  ][  ][  ][  ][  ] |[  ][  ][  ][  ][  ]  
    //          a[0]                a[1]                 a[2]             a[3]                    a[4]     
    //                |                 |                 |                 |                |
    //p               p+1               p+2               p+3               p+4
    //p[4][2] = *(*(p+4)+2)                                                         |p[4][2]          |a[4][2]    
    //二维数组存储也是连续存放的
    //&p[4][2] - &a[4][2] = -4，大地址 - 小地址 = 中间元素的个数
    //%d - -4
    //%p - 地址是一个无符号数，将该数的补码转为无符号数，再以原码打印0xFF FF FF FC
	//10000000 00000000 0000000 00000100 = -4的原码
	//11111111 11111111 1111111 11111100 = -4的补码
	//将-4作为无符号数，转为原码还是11111111 11111111 1111111 11111100
	//以%p打印原码：FF FF FF FC
    return 0;
}
*/

//笔试题6：
/*
int main()
{
    int aa[2][5] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    //[][][][][]|[][][][][]
    //|&aa                 |ptr1
    //|aa        |ptr2
    int* ptr1 = (int*)(&aa + 1);//&aa - 此时aa是整个数组，即整个数组的地址，需要数字指针保存，故强制类型转换
    //&aa + 1，跳过整个数组
    //强制类型转换，只是类型发生了改变，值不改变
    int* ptr2 = (int*)(*(aa + 1));//aa是数组名，是一维数组的地址，此时aa是第一行的地址,第一行的地址解引用为第一行的数组名
    //*(aa + 1) = aa[1]，找到了第二行，即第二行的数组名aa[1]，第二行首元素6的地址，故可以不强制类型转换，是多余的代码
    //aa + 1，跳过一行
    printf("%d,%d", *(ptr1 - 1), *(ptr2 - 1));
    //*(ptr1 - 1) - 跳过一个整型，即10的地址
    //*(ptr2 - 1) - 跳过一个整型，即5的地址
    return 0;
}
*/
//回顾
//int arr[10] = { 1,2,3,4,5 };
//int* p = arr;
//*(p + 2) = p[2] = *(arr + 2) = arr[2];

//笔试题7：
/*
int main()
{
    char* a[] = { "work","at","alibaba" };//字符指针数组，每个字符指针存放字符串常量的首字符地址
    char* *pa = a;//首元素的地址赋值给了pa，pa指向的元素是char*类型
    //内存存储：a[] = {&p1, &p2, &p3}
    // char* p1 = "work" 
    // char* p2 = "at" 
    // char* p3 = "alibaba"
    // char* *pa = a = &p1
    //pa++，即跳过char*，
    pa++;//跳过char*大小，即每个字符指针都是char*，故跳到下一个字符串
    printf("%s\n", *pa);//at  - pa++ == &p2 ，*pa == &'a'
    return 0;
}
*/
//回顾：
//int *p;
//p + 1;//跳过一个int大小
//char* *p;
//p + 1;//跳过一个cha*大小
//int *p = &a;
//int **pp = &p;
//*pp == p;对pp中保存的地址解引用，找到p
//*p == a;对p中保存的地址解引用，找到a

//笔试题8：
/*
int main()
{
    char* c[] = { "ENTER","NEW","POINT","FIRST" };
    char* *cp[] = { c + 3,c + 2,c + 1,c };
    char** *cpp = cp;
    printf("%s\n", **++cpp);//POINT
    printf("%s\n", *-- * ++cpp + 3);//ER
    printf("%s\n", *cpp[-2] + 3);//ST
    printf("%s\n", cpp[-1][-1] + 1);//EW
    return 0;
}
*/
//前三行代码的内存布局：
//                          cp[]						   c[]
//                          cp[0]:c+3 == &c[3]             c[0]     char*   -----> "ENTER"
//      cpp == &cp[0]       cp[1]:c+2 == &c[2]             c[1]     char*   -----> "NEW"
//                          cp[2]:c+1 == &c[1]             c[2]     char*   -----> "POINT"
//                          cp[3]:c   == &c[0]             c[3]     char*   -----> "FIRST"
//cpp+/-整数，指针偏移char**类型大小个字节
//cpp中存入cp的地址，cp中存入c+整数的地址，c中存入字符串首元素的地址
//c+3指向c[3]的地址，c+2指向c[2]的地址，c+1指向c[1]的地址，c指向c[0]的地址
//1、**++cpp = *(*(++cpp)),cp是cp[]首元素的地址，cpp指向cp[0]的地址，++cpp指向cp[1]的地址，cpp指向cp[1]的地址
//*(++cpp)，cp[1]地址解引用得到c+2，即得到c[2]的地址，*(*(++cpp))，c[2]的地址解引用，找到c[2]的首元素地址，往后数直到遇见'\0'
//2、*-- * ++cpp + 3 = *(--(*(++cpp)))+ 3，由于前面++cpp，cpp指向cp[1]的地址，故再++cpp指向cp[2]的地址，
//*(++cpp))，cp[2]的地址解引用，得到c+1，即得到c[1]的地址，--(*(++cpp)),即c+1进行--得到c，此时指向c[0],即得到了c[0]的地址，
//*(--(*(++cpp)))找到c[0]的首元素地址，*(--(*(++cpp)))+ 3，偏移3个字节，得到第四个字符的地址，往后数直到遇见'\0'
//3、*cpp[-2] + 3 = *(*(cpp-2))+3，由于前面cpp指向cp[2]的地址，cpp-2指向cp[0]的地址，
//*(cpp-2)，cp[0]的地址得到c+3，即得到c[3]的地址，*(*(cpp-2))，c[3]的地址解引用，找到c[3]的首元素地址，
//*(*(cpp-2))+3，偏移3个字节，得到第四个元素的地址，往后数直到遇到'\0'
//4、cpp[-1][-1] + 1 = *(*(cpp-1)-1)+1，由于cpp没有发生变化，cpp仍指向cp[2]的地址，
//cpp-1指向cp[1]的地址，*(cpp-1)，cp[1]的地址解引用得到c+2，即得到c[2]的地址，*(cpp-1)-1，即(c+2) - 1得到c+1，此时指向c[1]的地址，
//*(*(cpp-1)-1)，解引用c[1]的地址，找到c[1]的首元素地址，*(*(cpp-1)-1)+1，偏移1个字节，得到第二个字符的地址，往后数直到遇见'\0'