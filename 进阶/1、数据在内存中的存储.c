#define _CRT_SECURE_NO_WARNINGS 1
//数据在内存中的存储
//1. 数据类型详细介绍
//C语言类型分为：内置类型、自定义类型
//内置类型：
//char        //字符数据类型	//1个字节
//short       //短整型			//2个字节
//int         //整形			//4个字节
//long        //长整型			//4/8个字节
//long long   //更长的整形		//8个字节
//float       //单精度浮点数	//4个字节
//double	  //双精度浮点数	//8个字节
//自定义类型：也叫构造类型

//类型的意义：
//1. 使用这个类型开辟内存空间的大小（大小决定了使用范围）。
//2. 如何看待内存空间的视角。

//类型的基本归类：
//整形家族：
//char
//		unsigned char
//		signed char
//short
//		unsigned short[int]
//		signed short[int]
//int
//		unsigned int
//		signed int
//long
//		unsigned long[int]
//		signed long[int]

//浮点数家族：
//float
//double

//构造类型：
//数组类型
//结构体类型 struct
//枚举类型 enum
//联合类型 union

//指针类型
//int* pi;
//char* pc;
//float* pf;
//void* pv;

//空类型：
//void 表示空类型（无类型）
//通常应用于函数的返回类型、函数的参数、指针类型。
/*
#include <stdio.h>
void test()
{
	printf("hehe\n");
}
int main()
{
	test(100);
	return 0;
}
*/
//返回类型如果是void，可以省略不写.C语言对函数返回类型检查不严格
//C语言对无参的函数调用，可以传参也可以不传参，C语言对函数参数个数检查不严格
//如果确定不想要传参，可以void test(void)，此时再传参就会报警告

//2. 整形在内存中的存储：原码、反码、补码
//整数：有符号数（正数、负数）、无符号数
//计算机中的整数有三种表示方法，即原码、反码和补码。(无符号数的原码、反码、补码相同)
//三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位负整数的三种表示方法各不相同。

//负数的原码、反码、补码
//原码：直接将二进制按照正负数的形式翻译成二进制就可以。
//反码：将原码的符号位不变，其他位依次按位取反就可以得到了。
//补码：反码 + 1就得到补码。

//正数的原码、反码、补码都相同。
/*
#include <stdio.h>
int main()
{
	int a = 20;//4个字节 - 32bit
	//00000000 00000000 00000000 00010100 - 原码
	//00000000 00000000 00000000 00010100 - 反码
	//00000000 00000000 00000000 00010100 - 补码
	//计算机中的存放值为：0x00 00 00 14
	//F10执行到通过return 0;调试-窗口-内存：观察&a，发现该地址指向的空间存放的是14 00 00 00
	int b = -10;
	//10000000 00000000 00000000 00001010 - 原码
	//11111111 11111111 11111111 11110101 - 反码
	//11111111 11111111 11111111 11110110 - 补码
	//计算机中的存放值为：0xFF FF FF F6
	//F10执行到通过return 0;调试-窗口-内存：观察&a，发现该地址指向的空间存放的是F6 FF FF FF 
	return 0;
}
*/
//对于整形来说：数据存放在内存中，其实存放的是该数的补码。为什么呢？
//在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；
//同时，加法和减法也可以统一处理（CPU只有加法器）此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。

//3. 大小端字节序介绍及判断
//在内存中的存储：
//对于a和b分别存储的是补码。但是存放的顺序是倒序的。这是又为什么？
//大小端介绍：
//大端（存储）模式，是指数据的高位，保存在内存的低地址中；
//小端（存储）模式，是指数据的低位，保存在内存的低地址中。
//数据位：左边高，右边低。内存地址：左边低，右边高
//当前计算机存储的方式是小端存储方式，如：0x11223344  11是高位，44是低位，存放的顺序是44(低地址) 33 22 11(高地址)
//注意：数据的存储和运算都是以补码的值，按字节序存放在内存中，打印和显示该数据是以原码的值，还原数据的顺序

//设计一个小程序来判断当前机器的字节序。
//假设当前计算机存储了一个数1
/*
#include <stdio.h>
int main()
{
	int a = 1;
	//计算机存放1的值为：0x 00 00 00 01
	//					   低地址-高地址
	//小端计算机存储的方式：01 00 00 00
	//大端计算机存储的方式：00 00 00 01
	char* p = (char*) &a;//由于p是存放地址的，故可以存放的下a的地址，通过char*类型的解引用，访问一个字节
	//强制类型转换，否则会报警告
	if (*p == 1)//表达式中的 字符 和 短整型 操作数在使用之前被转换为普通整型，这种转换称为整型提升。
		printf("小端\n");
	else
		printf("大端\n");
	return 0;
}
*/
//如果某个操作数的类型在下面这个列表中排名较低，那么首先要转换为另外一个操作数的类型后执行运算。这种转换称为算数转换
//long double
//double
//float
//unsigned long int
//long int
//unsigned int
//int
//指针类型的意义：
//1、指针类型决定了指针解引用操作符能访问几个字节：char* p;*p访问1个字节，int* p；*p访问4个字节
//2、指针类型决定了指针+n/-n，跳过是几个字节：char* p;p+1跳过一个字节，int* p;p+1，跳过一个整型4个字节
/*
#include <stdio.h>
int main()
{
	int a = 0x11223344;
	int* p1 = &a;
	*p1 = 0;//通过调试-内存观察:44 33 22 11--00 00 00 00
	char* p2 = &a;
	*p2 = 0;//通过调试-内存观察:44 33 22 11--00 33 22 11
	return 0;
}
*/

/*
#include <stdio.h>
//1、
int check_sys()
{
	int a = 1;
	char* p = (char*) &a;//&a的类型是int*
	if (*p == 1)
		return 1;
	else
		return 0;
}
//2、
int check_sys()
{
	int a = 1;
	char* p = (char*)&a;//强制类型转换，数据的值是不会发生变化的
	return *p;
}
//3、
int check_sys()
{
	int a = 1;
	return *(char*)&a;
}
int main()
{
	int ret = check_sys();
	if (ret == 1)
		printf("小端\n");
	else
		printf("大端\n");
	
	return 0;
}
*/
 
//练习：
//1.输出什么？
/*
#include <stdio.h>
int main()
{
    //-1为整型：10000000 00000000 00000000 00000001
    //补码：11111111 11111111 11111111 11111111
    char a = -1;//a为有符号数，符号位为1
    //a中存放：11111111
    signed char b = -1;//b为有符号数，符号位为1
    //b中存放：11111111
    unsigned char c = -1;//c为无符号数，无符号位
    //c中存放：11111111
    printf("a=%d,b=%d,c=%d", a, b, c);
    //由于是以%d整型打印，故先需整型提升，再以有符号数打印
    //各变量中的补码：
    //a：11111111 11111111 11111111 11111111//该a为有符号数，整型提升，符号位为1高位补1
    //b：11111111 11111111 11111111 11111111//该b为有符号数，整型提升，符号位为1高位补1
    //c：00000000 00000000 00000000 11111111//该c为无符号数，整型提升，高位补0
    //打印的是原码为：-1、-1、255
    return 0;
}
*/

//2.输出什么？
/*
#include <stdio.h>
int main()
{
    char a = -128;//a为有符号数，符号位为1
    //128的原码：10000000 00000000 00000000 10000000
    //128的补码：11111111 11111111 11111111 10000000
    //a = 10000000
    printf("%u\n", a);
    //%d - 打印十进制的有符号数字
    //%u - 打印十进制的无符号数字
    //由于以无符号整型打印。故先需要整型提升，再以无符号数打印
    //11111111 11111111 11111111 10000000//该a为有符号数，整型提升，符号位为1高位补1
    //以无符号打印的是原码(原反补相同)为：4292967168
    return 0;
}
*/
//对于char类型1个字节在内存的范围：
//  补码  (原码)有符号数char   无符号数char
//00000000      0               0
//00000001      1               1
//00000010      2               2
//...           ...             ...
//01111111      127             127
//10000000      -128            128
//10000001      -127            129
//...           ...             ...
//11111101      -3              253
//11111110      -2              254
//11111111      -1              255
//补码取反+1 = 原码  原码取反+1 = 补码
//注意：对于有符号char类型，-128的原码、补码相同。127+1 = -128，-128-1= 127
//注意：对于无符号char类型，255 + 1 = 0，0 - 1 = 255
//注意：char的范围：0，1，2...127,-128,-126...-2,-1
//-128~127、0~255

//3.输出什么？
/*
#include <stdio.h>
int main()
{
    char a = 128;//127+1,即a = -128
	//00000000 00000000 00000000 10000000
	//a = 10000000
	//11111111 11111111 11111111 10000000//该a为有符号数，整型提升，符号位为1高位补1
	//以无符号打印的是原码(原反补相同)为：4292967168
    printf("%u\n", a);//结果同例题2的结果
    return 0;
}
*/

//4.输出什么？
//按照补码的形式进行运算，最后格式化成为有符号整数
/*
#include <stdio.h>
int main()
{
    int i = -20;
    //-20的原码：10000000 00000000 00000000 00010100
    //11111111 11111111 11111111 11101100
    //i中存的值为：11111111 11111111 11111111 11101100
    unsigned int j = 10;
    // 10的原码：00000000 00000000 00000000 00001010
    //j中存的值为：00000000 00000000 00000000 00001010
    printf("%d\n", i + j);//算术转换
    //i = 11111111 11111111 11111111 11101100，转为无符号数后，与j相加
    //j = 00000000 00000000 00000000 00001010
    //    11111111 11111111 11111111 11110110
    //i + j = 11111111 11111111 11111111 11110110，为无符号数
	//因为以%d形式打印原码，即以有符号整数打印，
	//11111111 11111111 11111111 11110110，该数的高位1为符号位
    //原码取反 + 1 = 补码，补码取反 + 1 = 原码
    //该数对应的原码为：10000000 00000000 00000000 00001010
    //打印原码：-10
    return 0;
}
*/

//5.输出什么？
/*
#include <stdio.h>
#include <windows.h>
int main()
{
    unsigned int i;
    for (i = 9; i >= 0; i--)
    {
        Sleep(100);//100ms
        printf("%u\n", i);
    }
    return 0;
}
*/
//-1 = 1000000 0000000 0000000 0000001
//     1111111 1111111 1111111 1111111
//打印无符号数的原码(原反补相同)1111111 1111111 1111111 1111111 = 4292967295
//由于i存放的是无符号数，永远大于0，当i = -1是仍是一个大于0的数，故结果9、8、7、6、5、4、3、2、1、0、4292967295...

//6.输出什么？
/*
#include <stdio.h>
int main()
{
    char a[1000];//{-1,-2,-3,...,-1000} = {-1,-2,-3,...,-128,127,126,...,2,1,0,-1,-2...}
    int i;
    for (i = 0; i < 1000; i++)
    {
        a[i] = -1 - i;
    }
    printf("%d", strlen(a));//255
    return 0;
}
*/
//对于有符号char类型：127 + 1 = -128 ，-128 - 1 = -127
//将a[1000]的所有元素转化-128~127中的数字，寻找\0（即：\0-转换成ASCII码0）
//由此可知，strlen可以求字符数组的长度，也可以求字符串的长度

//7.输出什么？
/*
#include <stdio.h>
int main()
{
    unsigned char a = 256;//255 + 1 = 0
    //256 = 0000000 0000000 0000001 00000000
    //补码为：0000000 0000000 0000001 00000000
    //a = 00000000
    //打印原码：00000000
    printf("%u\n",a);
    return 0;
}
*/

//8.输出什么？
/*
#include <stdio.h>
unsigned char i = 0;//存放了范围为0-255
int main()
{
    for (i = 0; i <= 255; i++)
    {
        printf("hello world\n");
    }
    return 0;
}
*/
//当i = 255时，255 + 1 = 0，故会死循环打印
//注意：未来创建无符号变量时，注意是否造成死循环。

//4. 浮点型在内存中的存储解析
//常见的浮点数：3.14159、1E10（1E10 = 1.0^10）
/*
#include <stdio.h>
int main()
{
	double d = 1E10;
	printf("%lf\n", d);
	return 0;
}
*/
//浮点数家族包括： float、double、long double 类型。
//浮点数表示的范围：在float.h中有定义
//char、short、int、long的表示范围：在limits.h中有定义
//通过VS安装路径下的include文件夹下的float.h、limits.h可以查看知道
/*
#include <stdio.h>
int main()
{
    int n = 9;

    float* pFloat = (float*)&n;
    printf("n的值为：%d\n", n);//9
    printf("*pFloat的值为：%f\n", *pFloat);//0.000000
   
    *pFloat = 9.0;
   
    printf("num的值为：%d\n", n);//1091567616
    printf("*pFloat的值为：%f\n", *pFloat);//9.000000
    return 0;
}*/
//可知浮点数与整型的，在计算机中的存储方式是不同的

//浮点数存储规则
//根据国际标准IEEE（电气和电子工程协会） 754，任意一个二进制浮点数V可以表示成下面的形式：
//(-1)^S * M * 2^E
//S表示符号位，当s = 0，浮点数V为正数；当s = 1，浮点数V为负数。
//M表示有效数字，大于等于1，小于2。
//E表示指数。
//举例来说：
//十进制的5.0，写成二进制是 101.0 ，相当于 1.01 × 2^2 。
//那么，按照上面V的格式，可以得出S = 0，M = 1.01，E = 2。
//十进制的-5.0，写成二进制是-101.0 ，相当于-1.01×2 ^ 2 。那么，S = 1，M = 1.01，E = 2。

//IEEE 754规定：
//对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。
//对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。

//IEEE 754对有效数字M和指数E，还有一些特别规定。
//M的存放：
//前面说过， 1 <= M < 2 ，也就是说，M可以写成 1.xxxxxx 的形式，其中xxxxxx表示小数部分。
//IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。
//比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。
//以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。

//E的存放：
//E为一个无符号整数（unsigned int）
//如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047。但是，需注意在数学中，科学计数法中的E是可以出现负数的，
//所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。
//比如，2^10的E是10，所以保存成32位浮点数时，必须将E保存成10 + 127 = 137（加上中间值127），即10001001。
//又比如：浮点数0.5对应的二进制为0.1：(-1)^0 * 1.0 * 2^-1，所以保存成32位浮点数时，必须将E保存成-1 + 127 = 126（加上中间值127），即01111110。
//注意：不管E是否为正数或负数，都要加上相应的中间值
/*
#include <stdio.h>
int main()
{
    float f = 5.5;
    //5.5 = 101.1 = (-1)^0 * 1.011 * 2^2
    //S = 0
    //M = 1.011(只存储011)
    //E = 2 = 二进制10(即存储2 + 127 = 10000001) 
    //符号位S   指数E        有效数据M 
    //  0     10000001    01100000000000000000000
    //01000000 10110000 00000000 00000000  = 0x 40 b0 00 00 00
    //注意：小数部分补零是在后面补0
    //f变量中数据的值在计算机中的存储形式：00 00 b0 40,由此可见也是小端字节序
    
    return 0;
}
*/

//E的取出：
//指数E从内存中取出还可以再分成三种情况：

//E不全为0或不全为1
//这时，浮点数就采用下面的规则表示，
//即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。(因为1.xxxxxx，只保留了xxxxxx，故还原要加上)
//比如：0.5的二进制形式为0.1，由于规定M必须为1.xxxxxx，即需将小数点右移1位，
//则为1.0 * 2^(-1)，其阶码为 - 1 + 127 = 126，表示为01111110，而尾数1.0去掉整数部分为0，补齐0到23位00000000000000000000000，
//则其二进制存储形式为 :0 01111110 00000000000000000000000

//E全为0
//说明：指数部分加上127后为0，真实值为-127，该浮点数为：(-/+)1.xxxx * 2^-127，此为一个极小的值
//这时，规定：浮点数的指数E就等于1 - 127（或者1 - 1023）即为真实值，
//有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。
//比如：0 00000000 01100000000000000000000，还原：+0.011 * 2^(-126) ，此时真实的指数不按0-128计算

//E全为1
//说明：指数部分加上127后为255，真实值为128，该浮点数为：(-/+)1.xxxx * 2^128，此为一个极大的值
//这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；即1.xxxxx * 2^128

//浮点数存储的例子：
/*
#include <stdio.h>
int main()
{
    int n = 9;
    //00000000 00000000 00000000 00001001 - 补码
    float* pFloat = (float*)&n;
    printf("n的值为：%d\n", n);//9
    printf("*pFloat的值为：%f\n", *pFloat);
    //将00000000 00000000 00000000 00001001站在浮点数的存储形式看问题
    //此时站在*pFloat角度，以%f形式打印，里面存放的是浮点数：0 00000000 000000000000000000001001
    //E为全0，还原：(-1)^0 * 0.000000000000000000001001 * 2^(-126)，故打印0.000000
    *pFloat = 9.0;
    //1001.0 = (-1)^0 * 1.001 * 2^3
    //0 10000010 001000000000000000000000
    printf("num的值为：%d\n", n);
    //将0 10000010 001000000000000000000000站整型的存储形式看问题
    //以%d形式打印，里面存放的是整型：0 10000010001000000000000000000000，故打印原码：1091567616
    printf("*pFloat的值为：%f\n", *pFloat);//9.0
    return 0;
}
*/