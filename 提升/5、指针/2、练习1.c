#define _CRT_SECURE_NO_WARNINGS 1
//作业1：
//1、能把函数处理结果的两个数据返回给主调函数，在下面的方法中不正确的是：
//正确答案A.return 这两个数
//B.形参用数组
//C.形参用两个指针
//D.用两个全局变量
//return只能返回一个数

//2、关于函数调用说法不正确的是：
//A.函数可以传值调用，传值调用的时候形参是实参的一份临时拷贝
//B.函数可以传址调用，传址调用的时候可以通过形参操作实参
//正确答案C.函数可以嵌套定义，但是不能嵌套调用
//D.函数可以嵌套调用，但是不能嵌套定义
//嵌套调用：A调用B，B调用C

//3、在函数调用时，以下说法正确的是：
//A.函数调用后必须带回返回值
//正确答案B.实际参数和形式参数可以同名
//C.函数间的数据传递不可以使用全局变量
//D.主调函数和被调函数总是在同一个文件里

//4、关于函数的声明和定义说法正确的是：
//A.函数的定义必须放在函数的声明之前
//正确答案B.函数必须保证先声明后使用
//C.函数定义在使用之后，可以不声明
//D.函数的声明就是说明函数是怎么实现的//这个是函数的定义

//5、关于实参和形参描述错误的是：
//A.形参是实参的一份临时拷贝
//B.形参是在函数调用的时候才实例化，才开辟内存空间
//正确答案C.改变形参就是改变实参
//D.函数调用如果采用传值调用，改变形参不影响实参

//6、函数调用exec((v1,v2),(v3,v4),v5,v6)，实参的个数是：
//A.3
//正确答案B.4//(v1,v2)和(v3,v4)是逗号表达式，只能算两个参数
//C.5
//D.6

//7、以下关于函数设计不正确的说法是：
//A.函数设计应该追求高内聚低耦合//内聚指函数之间的独立性，耦合指函数之间的关联性
//正确答案B.要尽可能多的使用全局变量
//C.函数参数不易过多
//D.设计函数时，尽量做到谁申请的资源就由谁来释放

//8、关于C语言函数描述正确的是：
//A.函数必须有参数和返回值
//B.函数的实参只能是变量
//正确答案C.库函数的使用必须要包含对应的头文件
//D.有了库函数就不需要自定义函数了

//9、C语言规定，在一个源程序中，main函数的位置：
//A.必须在最开始
//B.必须在库函数的后面
//正确答案C.可以任意
//D.必须在最后

//10、以下叙述中不正确的是：
//A.在不同的函数中可以使用相同名字的变量
//B.函数中的形式参数是在栈中保存
//C.在一个函数内定义的变量只在本函数范围内有效
//正确答案D.在一个函数内复合语句中定义的变量在本函数范围内有效(复合语句指函数中的成对括号构成的代码)
//注意：复合语句中定义的static修饰的变量，同样出了复合语句也无效，static只延长生命周期，不改变作用域。
/*
#include <stdio.h>
int main()
{
	{
		static int a = 10;
	}
	printf("a = %d\n", a);//报错
	return 0;
}
*/

//11、关于一维数组初始化，下面哪个定义是错误的？
//A.int arr[10] = {1,2,3,4,5,6};
//B.int arr[] = {1,2,3,4,5,6};
//正确答案C.int arr[] = (1,2,3,4,5,6);
//D.int arr[10] = {0};

//12、以下能对二维数组a进行正确初始化的语句是：
//A.int a[2][] = {{0,1,2},{3,4,5}};
//正确答案B.int a[][3] = {{0,1,2},{3,4,5}};
//C.int a[2][4] = {{0,1,2},{3,4},{5}};
//D.int a[][3] = {{0,,2},{},{3,4,5}};

//13、定义了一维int型数组a[10]后，下面错误的引用是：
//A.a[0] = 1;
//B.a[0] = 5*2;
//正确答案C.a[10] = 2;
//D.a[1] = a[2]*a[0];

//14、若定义int a[2][3] = {1,2,3,4,5,6};则值为4的数组元素是：
//A.a[0][0]
//正确答案B.a[1][0]
//C.a[1][1]
//D.a[2][1]

//15、下面代码的结果是：
/*
#include <stdio.h>
int main()
{
	int arr[] = { 1,2,(3,4),5 };
	printf("%d\n",sizeof(arr));
	return 0;
}
*/
//A.4
//正确答案B.16
//C.20
//D.5

//15、下面代码的结果是：
/*
#include <stdio.h>
#include <string.h>
int main()
{
	char str[] = "hello bit";
	printf("%d %d\n", sizeof(str),strlen(str));
	return 0;
}
*/
//正确答案A.10 9
//B.9 9
//C.10 10
//D.9 10

//16、给出以下定义：？？？
/*
	char acX[] = "abcdefg";
	char acY[] = {'a','b','c','d','e','f','g'};*/
//以下说法正确的是：
//A.数组acX和数组acY等价
//B.数组acX和数组acY的长度相同
//C.数组acX的长度大于数组acY的长度
//正确答案D.数组acX的长度小于数组acY的长度

//17、关于一维数组描述不正确的是：
//A.数组的下标是从0开始的
//B.数组在内存中是连续存放的
//C.数组名表示首元素的地址
//正确答案D.随着数组下标的由小到大，地址由高到低//由低到高

//18、实现一个整型数组的冒泡排序
/*
#include <stdio.h>
void sort(int arr[], int sz)
{
	int flag = 0;
	for (int i = 0; i < sz - 1; i++)
	{
		for (int j = 0; j < sz - i - 1; j++)
		{
			if (arr[j] > arr[j + 1])
			{
				int tmp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = tmp;
				flag = 1;
			}
		}
		if (flag == 0)
			break;
	}
}
int main()
{
	int arr[] = { -9, 0, 4, 8, 9 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	sort(arr, sz);
	for (int i = 0; i < sz; i++)
		printf("%d ", arr[i]);
	return 0;
}
*/

//19、创建一个整型数组，完成对数组的操作
//1、实现函数Init()初始化数组为全0
//2、实现Print()打印数组的每一个元素
//3、实现Everse()函数完成数组元素的逆置
/*
void Init(int* arr,int sz)
{//1、实现函数Init()初始化数组为全0
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		*(arr + i) = 0;//相当与*arr++  = 0;//此方法形参为int* arr,int sz
		//arr[i] = 0;//此方法形参int arr[],int sz
	}
}
void Print(int arr[],int sz)
{//2、实现Print()打印数组的每一个元素
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		printf("%d ",arr[i]);
	}
}
void Everse(int arr[],int sz)
{//3、实现Everse()函数完成数组元素的逆置
	int left = 0;
	int right = sz - 1;
	int i = 0;
	while (left < right)
	{
		int tmp = 0;
		tmp = arr[left];
		arr[left] = arr[right];
		arr[right] = tmp;
		left++;
		right--;
	}
}
#include <stdio.h>
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	//Init(arr,sz);
	//Print(arr,sz);
	//由于函数内已经封装了打印操作，故可以直接调用，直接输出，而这样写是错误的printf(Print(arr,sz))
	Everse(arr,sz);
	Print(arr, sz);
	return 0;
}
*/

//20、将数组A中的内容和数组B中的内容进行交换（数组一样大）
/*
#include <stdio.h>
int main()
{
	int arr1[] = { 1,2,3,4,5 };
	int arr2[] = { 6,7,8,9,10 };
	int sz = sizeof(arr1) / sizeof(arr1[0]);
	int i = 0;
	for (i = 0; i < sz; i++)
	{
		int tmp = 0;
		tmp = arr1[i];
		arr1[i] = arr2[i];
		arr2[i] = tmp;
	}
	//通过调试也可以观察到元素之间的交换
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr1[i]);
	}
	printf("\n");
	for (i = 0; i < sz; i++)
	{
		printf("%d ", arr2[i]);
	}
	return 0;
}
*/

//21、关于表达式求值说法不正确的是：
//A.表达式求值先看是否存在整型提升或算术转换，再进行计算
//B.表达式真正计算的时候先看相邻操作符的优先级决定谁先算
//C.相邻操作符的优先级相同的情况下，看操作符的结合性决定计算顺序
//正确答案D.只要有了优先级和结合性，表达式就能求出唯一值

//22、下面代码的结果是：
/*
#include <stdio.h>
int main()
{
	int i = 1;
	int ret = (++i) + (++i) + (++i);
	printf("ret = %d\n", ret);
	return 0;
}
*/
//A.10 
//B.12 //4 4 4
//C.9  //2 3 4
//正确答案D.程序错误

//23、关于的概念，错误的是：
//A.指针是变量，用来存放地址
//B.指针变量中存放的有效地址可以唯一指向内存中的一块区域
//正确答案C.野指针也可以正常使用
//D.局部指针变量不初始化就是野指针

//24、以下系统中，int类型占几个字节，指针占几个字节，操作系统可以使用的最大内存空间是多大：
//A.32位下：4，4，2^32		64位下：8，8，2^64
//B.32位下：4，4，不限制	64位下：4，8，不限制
//正确答案C.32位下：4，4，2^32	64位下：4，8，2^64
//D.32位下：4，4，2^32	64位下：4，4，2^64

//25、下面代码的结果是：
/*
#include <stdio.h>
int main()
{
	int arr[] = { 1,2,3,4,5 };
	short* p = (short*)arr;
	int i = 1;
	for (i = 0; i < 4; i++)//循环了四次
	{
		*(p + i) = 0;
	}
	for (i = 0; i < 5; i++)//循环了五次
	{
		printf("%d ", arr[i]);
	}
	return 0;
}
*/
//A.1 2 3 4 5
//正确答案B.0 0 3 4 5
//C.0 0 0 0 5
//D.1 0 0 0 0

//26、下面代码输出的结果是：
/*
#include <stdio.h>
int main()
{
	int a = 0x11223344;//四个字节：内存中存放的顺序是44 33 22 11
	char* pc = (char*)&a;//pc指向的是a的地址，即44的前面所在位置
	*pc = 0;//由于pc是char*类型，解引用只能操作一个字节
	printf("%x\n ", a);//%x - 十六进制形式打印，打印的时候还原顺序
	return 0;
}
*/
//A.00223344
//B.0
//正确答案C.11223300
//D.112233

//算术转换
//如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类型，否则操作就无法进行。
//下面的层次体系称为寻常算术转换。即占字节小的类型可以转为占字节大的类型，精度小的可以转为精度大的
//long double
//double
//float
//unsigned long int
//long int
//unsigned int
//int
//如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另外一个操作数的类型后执行运算。
//如：两个long int 和int类型的数进行运算，会隐式将int类型的数据转为long int类型。
//27、下面代码输出的结果是：
/*
#include <stdio.h>
int i;//全局变量-不初始化默认赋初值0
int main()
{
	i--;//-1
	if (i > sizeof(i))//sizeof(i) = 4，计算变量/类型所占内存的大小，即恒大于等于0，也就是无符号数
	{//将-1转换为无符号数，
	 //-1的原码：10000000 00000000 00000000 000000001
	 //-1的补码：11111111 11111111 11111111 111111111
	 //转为无符号数：11111111 11111111 11111111 111111111 > 4
		printf(">\n");
	}
	else
	{
		printf("<\n");
	}
	return 0;
}
*/
//正确答案A.>
//B.<
//C.不输出
//D.程序有问题

//28、下面代码输出的结果是：
/*
#include <stdio.h>
int main()
{
	int a, b, c;
	a = 5;
	c = ++a;//c = 6,a = 6
	b = ++c, c++, ++a, a++;//c = 8,b = a++ = 7,a = 8
	b += a++ + c;//a = 9,c = 8,b = 8 + 8 + 7
	printf("a = %d b = %d c = %d\n", a, b, c);
	return 0;
}
*/
//A.a = 8 b = 23 c = 8
//正确答案B.a = 9 b = 23 c = 8
//C.a = 9 b = 25 c = 8
//D.a = 9 b = 24 c = 8

//29、下面哪个是位操作符：
//正确答案A.&
//B.&&
//C.||
//D.！